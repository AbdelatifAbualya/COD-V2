<!DOCTYPE html>
<!-- saved from url=(0067)file:///home/abid/Desktop/LLM%20Playground%20(COT%20vs%20COD)2.html -->
<html lang="en" data-darkreader-mode="dynamic" data-darkreader-scheme="dark" data-darkreader-proxy-injected="true"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style class="darkreader darkreader--fallback" media="screen"></style><style class="darkreader darkreader--text" media="screen"></style><style class="darkreader darkreader--invert" media="screen">.jfk-bubble.gtx-bubble, .captcheck_answer_label > input + img, span#closed_text > img[src^="https://www.gstatic.com/images/branding/googlelogo"], span[data-href^="https://www.hcaptcha.com/"] > #icon, img.Wirisformula, a[data-testid="headerMediumLogo"]>svg, .d2l-navigation-link-image-container, .d2l-iframe-loading-container {
    filter: invert(100%) hue-rotate(180deg) contrast(90%) !important;
}</style><style class="darkreader darkreader--inline" media="screen">[data-darkreader-inline-bgcolor] {
  background-color: var(--darkreader-inline-bgcolor) !important;
}
[data-darkreader-inline-bgimage] {
  background-image: var(--darkreader-inline-bgimage) !important;
}
[data-darkreader-inline-border] {
  border-color: var(--darkreader-inline-border) !important;
}
[data-darkreader-inline-border-bottom] {
  border-bottom-color: var(--darkreader-inline-border-bottom) !important;
}
[data-darkreader-inline-border-left] {
  border-left-color: var(--darkreader-inline-border-left) !important;
}
[data-darkreader-inline-border-right] {
  border-right-color: var(--darkreader-inline-border-right) !important;
}
[data-darkreader-inline-border-top] {
  border-top-color: var(--darkreader-inline-border-top) !important;
}
[data-darkreader-inline-boxshadow] {
  box-shadow: var(--darkreader-inline-boxshadow) !important;
}
[data-darkreader-inline-color] {
  color: var(--darkreader-inline-color) !important;
}
[data-darkreader-inline-fill] {
  fill: var(--darkreader-inline-fill) !important;
}
[data-darkreader-inline-stroke] {
  stroke: var(--darkreader-inline-stroke) !important;
}
[data-darkreader-inline-outline] {
  outline-color: var(--darkreader-inline-outline) !important;
}
[data-darkreader-inline-stopcolor] {
  stop-color: var(--darkreader-inline-stopcolor) !important;
}
[data-darkreader-inline-bg] {
  background: var(--darkreader-inline-bg) !important;
}
[data-darkreader-inline-border-short] {
  border: var(--darkreader-inline-border-short) !important;
}
[data-darkreader-inline-border-bottom-short] {
  border-bottom: var(--darkreader-inline-border-bottom-short) !important;
}
[data-darkreader-inline-border-left-short] {
  border-left: var(--darkreader-inline-border-left-short) !important;
}
[data-darkreader-inline-border-right-short] {
  border-right: var(--darkreader-inline-border-right-short) !important;
}
[data-darkreader-inline-border-top-short] {
  border-top: var(--darkreader-inline-border-top-short) !important;
}
[data-darkreader-inline-invert] {
    filter: invert(100%) hue-rotate(180deg);
}</style><style class="darkreader darkreader--variables" media="screen">:root {
   --darkreader-neutral-background: var(--darkreader-background-ffffff, #181a1b);
   --darkreader-neutral-text: var(--darkreader-text-000000, #e8e6e3);
   --darkreader-selection-background: var(--darkreader-background-0060d4, #004daa);
   --darkreader-selection-text: var (--darkreader-text-ffffff, #e8e6e3);
}</style><style class="darkreader darkreader--root-vars" media="screen"></style><style class="darkreader darkreader--user-agent" media="screen">@layer {
html {
    background-color: var(--darkreader-background-ffffff, #181a1b) !important;
}
html {
    color-scheme: dark !important;
}
iframe {
    color-scheme: dark !important;
}
html, body {
    background-color: var(--darkreader-background-ffffff, #181a1b);
}
html, body {
    border-color: var(--darkreader-border-4c4c4c, #736b5e);
    color: var(--darkreader-text-000000, #e8e6e3);
}
a {
    color: var(--darkreader-text-0040ff, #3391ff);
}
table {
    border-color: var(--darkreader-border-808080, #545b5e);
}
mark {
    color: var(--darkreader-text-000000, #e8e6e3);
}
::placeholder {
    color: var (--darkreader-text-a9a9a9, #b2aba1);
}
input:-webkit-autofill,
textarea:-webkit-autofill,
select:-webkit-autofill {
    background-color: var(--darkreader-background-faffbd, #404400) !important;
    color: var(--darkreader-text-000000, #e8e6e3) !important;
}
::selection {
    background-color: var(--darkreader-background-0060d4, #004daa) !important;
    color: var(--darkreader-text-ffffff, #e8e6e3) !important;
}
::-moz-selection {
    background-color: var(--darkreader-background-0060d4, #004daa) !important;
    color: var(--darkreader-text-ffffff, #e8e6e3) !important;
}
}</style>
  
  <title>LLM Playground (COT vs COD)</title>
  <!-- Google Fonts -->
  <link href="./LLM Playground (COT vs COD)_files/css2" rel="stylesheet">
  <style>
    /* --------------------------------
       Global Styles
    -------------------------------- */
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 0;
      font-family: 'Roboto', sans-serif;
      background: linear-gradient(145deg, #0F0F0F 0%, #1F1F1F 100%);
      color: #e0e0e0;
      overflow: hidden;
    }
    .app-container {
      display: flex;
      height: 100vh;
      overflow: hidden;
    }
    /* --------------------------------
       Sidebar Styles
    -------------------------------- */
    .sidebar {
      width: 250px;
      background-color: rgba(30, 30, 30, 0.95);
      padding: 1rem;
      border-right: 1px solid #333;
      overflow-y: auto;
      box-shadow: 2px 0 5px rgba(0,0,0,0.4);
    }
    .sidebar h2 {
      margin-top: 0;
      margin-bottom: 1rem;
      font-size: 1.2rem;
      color: #fff;
    }
    .sidebar ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .sidebar li {
      padding: 0.5rem;
      margin-bottom: 0.5rem;
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
    .sidebar li:hover {
      background-color: #333;
    }
    .sidebar li.active {
      background-color: #444;
    }
      /* Enhanced Final Answer Styling */
  .final-answer {
    background-color: #2d3748;
    border: 1px solid #4a5568;
    border-radius: 8px;
    padding: 15px;
    margin-top: 10px;
    color: #edf2f7;
    font-family: 'Roboto', sans-serif;
    line-height: 1.5;
    position: relative;
    clear: both;
    overflow: hidden;
  }

  .final-answer-label {
    font-size: 0.7rem;
    color: #90cdf4;
    margin-bottom: 12px;
    text-transform: uppercase;
    letter-spacing: 1px;
    font-weight: bold;
    border-bottom: 1px dotted #5a7299;
    padding-bottom: 5px;
    display: block;
  }

  .message {
    position: relative !important;
    overflow: visible !important;
    padding-bottom: 20px; /* Add space for word count badge */
  }

  .word-count-badge {
    position: absolute;
    top: 4px;
    right: 4px;
    background-color: rgba(30, 30, 30, 0.9);
    color: #ddd;
    font-size: 0.7rem;
    padding: 3px 8px;
    border-radius: 12px;
    border: 1px solid #555;
    box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    white-space: nowrap;
    z-index: 5;
    max-width: 200px;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  /* Add this to ensure proper CoD styling */
  .cod-thinking {
    background-color: #1e293b !important;
    border-color: #3d4e63 !important;
    font-family: 'Roboto Mono', monospace !important;
  }

  /* Improved CoD step styling */
  .cod-step {
    display: flex;
    align-items: flex-start;
    padding: 8px 10px;
    margin-bottom: 12px !important;
    border-left: none !important;
    background-color: #2c3b4f;
    border-radius: 6px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.2);
  }
  
  /* Make thinking steps and final answer containers properly visible */
  .thinking-steps, .final-answer {
    width: 100% !important;
    display: block !important;
  }
  
  /* Improved word count breakdown display */
  .word-count-breakdown {
    font-size: 0.7rem;
    color: #aaa;
    margin-top: 3px;
    display: flex;
    gap: 8px;
    flex-direction: column;
  }
    .sidebar button {
      width: 100%;
      margin-top: 0.5rem;
      padding: 0.5rem;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background-color 0.3s ease;
      box-shadow: 0 1px 3px rgba(0,0,0,0.4);
    }
    /* Normal button style */
    .sidebar button:not(#downloadTxtBtn):not(#downloadPdfBtn) {
      background-color: #3a3a3a;
      color: #fff;
    }
    .sidebar button:not(#downloadTxtBtn):not(#downloadPdfBtn):hover {
      background-color: #4a4a4a;
    }
    /* Visual Studio‚Äìlike style for PDF/TXT download buttons */
    #downloadTxtBtn,
    #downloadPdfBtn {
      background-color: #1e1e1e;
      color: #d4d4d4;
      border: 1px solid #3c3c3c;
    }
    #downloadTxtBtn:hover,
    #downloadPdfBtn:hover {
      background-color: #2d2d2d;
    }
    /* --------------------------------
       Chat Container Styles
    -------------------------------- */
    .chat-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      background: linear-gradient(145deg, #181818 0%, #202020 100%);
      position: relative;
    }
    .chat-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem;
      background-color: rgba(30,30,30,0.95);
      border-bottom: 1px solid #333;
      box-shadow: 0 2px 4px rgba(0,0,0,0.5);
      z-index: 1;
    }
    .chat-header h1#pageTitle {
      margin: 0;
      font-size: 1.5rem;
      color: #fff;
      user-select: none;
    }
    .settings-btn {
      background: none;
      border: none;
      color: #fff;
      font-size: 1.2rem;
      cursor: pointer;
      margin-left: 0.5rem;
      transition: color 0.3s ease;
    }
    .settings-btn:hover {
      color: #ccc;
    }
    .chat-messages {
      flex: 1;
      padding: 1rem;
      overflow-y: auto;
      scroll-behavior: smooth;
    }
    .chat-input {
      display: flex;
      border-top: 1px solid #333;
      background-color: rgba(30,30,30,0.95);
      padding: 1rem;
      box-shadow: 0 -2px 4px rgba(0,0,0,0.3);
    }
    .chat-input textarea {
      flex: 1;
      resize: none;
      border: none;
      background-color: #2e2e2e;
      color: #fff;
      padding: 0.5rem;
      border-radius: 8px;
      font-size: 1rem;
      outline: none;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.4);
    }
    .chat-input button {
      margin-left: 1rem;
      padding: 0.5rem 1rem;
      background-color: #3a3a3a;
      border: none;
      color: #fff;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1rem;
      transition: background-color 0.3s ease;
      box-shadow: 0 1px 3px rgba(0,0,0,0.4);
    }
    .chat-input button:hover {
      background-color: #4a4a4a;
    }
    /* Model Selection Styles */
.model-select-container {
  position: relative;
  margin-bottom: 15px;
}

.model-dropdown {
  width: 100%;
  padding: 10px 15px;
  border: 1px solid #444;
  border-radius: 8px;
  background-color: #2a2a2a;
  color: #fff;
  font-size: 0.95rem;
  appearance: none;
  cursor: pointer;
  outline: none;
  box-shadow: inset 0 1px 2px rgba(0,0,0,0.2);
}

.dropdown-arrow {
  position: absolute;
  right: 15px;
  top: 50%;
  transform: translateY(-50%);
  color: #aaa;
  pointer-events: none;
  font-size: 0.7rem;
}

.model-dropdown:hover {
  border-color: #666;
  background-color: #333;
}

.model-dropdown:focus {
  border-color: #4a8cff;
  box-shadow: 0 0 0 2px rgba(74, 140, 255, 0.25);
}

.model-info-card {
  background-color: #2a2a2a;
  border: 1px solid #444;
  border-radius: 8px;
  margin-bottom: 20px;
  overflow: hidden;
}

.model-info-header {
  background-color: #333;
  padding: 10px 15px;
  font-weight: 500;
  border-bottom: 1px solid #444;
}

.model-info-body {
  padding: 15px;
}

.model-tags {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 12px;
}

.model-tag {
  background-color: #3a4a5c;
  color: #90cdf4;
  padding: 3px 8px;
  border-radius: 12px;
  font-size: 0.75rem;
}

.model-description {
  color: #ddd;
  font-size: 0.9rem;
  line-height: 1.4;
}
    /* --------------------------------
       Message Styles
    -------------------------------- */
    .message {
      clear: both;
      margin-bottom: 1.5rem;
      max-width: 80%;
      padding: 0.75rem 1rem;
      border-radius: 12px;
      line-height: 1.4;
      word-wrap: break-word;
      background-color: #2e2e2e;
      border: 1px solid #444;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
      position: relative;
      overflow: hidden;
    }
    .message.user {
      float: right;
      background-color: #3a3a3a;
      margin-left: 20%;
    }
    .message.bot {
      float: left;
      background-color: #2e2e2e;
      margin-right: 20%;
    }
    .message.bot.placeholder {
      font-style: italic;
      color: #888;
    }
    /* IMPROVED: Thinking steps and final answer styling */
    .message-container {
      width: 100%;
      overflow: hidden;
    }
    .thinking-steps {
      background-color: #252525;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
      font-family: 'Roboto Mono', monospace;
      font-size: 0.85rem;
      color: #aaa;
      white-space: pre-wrap;
      overflow-x: auto;
    }
    .thinking-label {
      font-size: 0.7rem;
      font-family: 'Roboto', sans-serif;
      color: #777;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-weight: bold;
      border-bottom: 1px dotted #555;
      padding-bottom: 5px;
    }
    .final-answer {
      background-color: #2d3748;
      border: 1px solid #4a5568;
      border-radius: 8px;
      padding: 15px;
      margin-top: 5px;
      color: #edf2f7;
    }
    .final-answer-label {
      font-size: 0.7rem;
      color: #90cdf4;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-weight: bold;
      border-bottom: 1px dotted #5a7299;
      padding-bottom: 5px;
    }
    .step {
      border-left: 2px solid #3a4a5c;
      padding-left: 10px;
      margin-bottom: 8px;
    }
    .word-count-badge {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: rgba(30, 30, 30, 0.9);
      color: #ddd;
      font-size: 0.7rem;
      padding: 3px 8px;
      border-radius: 12px;
      border: 1px solid #555;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
      white-space: nowrap;
      z-index: 5;
    }
    /* --------------------------------
       Code Block Styles
    -------------------------------- */
    pre {
      background-color: #1f1f1f;
      padding: 0.75rem;
      border-radius: 8px;
      overflow-x: auto;
      margin: 0.5rem 0;
      position: relative;
    }
    code {
      font-family: Consolas, monospace;
      color: #dcdcdc;
    }
    .code-block-container {
      position: relative;
      margin: 0.5rem 0;
      background-color: #1f1f1f;
      border-radius: 8px;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
      padding: 0.75rem;
    }
    .copy-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      background-color: #333;
      border: none;
      color: #fff;
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }
    .copy-btn:hover {
      background-color: #444;
    }
    /* --------------------------------
       Modal Styles - IMPROVED - FIX FOR TAB CONTENT DISPLAY
    -------------------------------- */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow-y: auto; /* Changed from auto to allow scrolling */
      background-color: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(3px);
    }
    .modal-content {
      background-color: #1e1e1e;
      margin: 5% auto;
      padding: 20px;
      border: 1px solid #333;
      width: 600px; /* Wider to accommodate settings */
      max-width: 90%; /* Ensure it works on mobile */
      border-radius: 10px;
      color: #fff;
      box-shadow: 0 4px 10px rgba(0,0,0,0.5);
      position: relative;
      max-height: 85vh; /* Limit height and enable scrolling */
      overflow-y: auto;
    }
    .modal-content label {
      display: block;
      margin-bottom: 5px;
      font-size: 0.9rem;
    }
    .modal-content input, .modal-content select {
      width: 100%;
      padding: 0.4rem;
      margin-bottom: 1rem;
      border: 1px solid #333;
      border-radius: 5px;
      background-color: #2e2e2e;
      color: #fff;
      font-size: 0.9rem;
      outline: none;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.4);
    }
    .modal-content select {
      appearance: none;
      background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23FFFFFF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
      background-repeat: no-repeat;
      background-position: right 0.7em top 50%;
      background-size: 0.65em auto;
      padding-right: 20px;
    }
    .modal-content button {
      padding: 0.5rem 1rem;
      background-color: #3a3a3a;
      border: none;
      color: #fff;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1rem;
      margin-right: 0.5rem;
      transition: background-color 0.3s ease;
      box-shadow: 0 1px 3px rgba(0,0,0,0.4);
    }
    .modal-content button:hover {
      background-color: #4a4a4a;
    }
    .settings-tabs {
      display: flex;
      gap: 5px;
      margin-bottom: 15px;
    }
    .tab-btn {
      flex: 1;
      background-color: #2a2a2a;
      border: 1px solid #444;
      color: #aaa;
      padding: 8px 0;
      border-radius: 5px 5px 0 0;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    .tab-btn.active {
      background-color: #3a3a3a;
      color: #fff;
      border-bottom: 2px solid #4a8cff;
    }
    .tab-content {
      display: none;
      padding: 15px;
      background-color: #2a2a2a;
      border-radius: 0 0 5px 5px;
      margin-bottom: 20px;
      /* Fix for tab content display issues */
      position: relative;
      width: 100%;
      box-sizing: border-box;
    }
    .tab-content.active {
      display: block;
    }
    .checkbox-container {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    .checkbox-container input[type="checkbox"] {
      width: auto;
      margin-right: 10px;
      margin-bottom: 0;
    }
    .tooltip {
      position: relative;
      display: inline-block;
      margin-left: 5px;
      cursor: help;
    }
    .tooltip .tooltiptext {
      visibility: hidden;
      width: 300px;
      background-color: #2e2e2e;
      color: #fff;
      text-align: left;
      border-radius: 6px;
      padding: 8px;
      position: absolute;
      z-index: 1;
      top: -5px;
      left: 105%;
      opacity: 0;
      transition: opacity 0.3s;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
      font-size: 0.8rem;
      line-height: 1.4;
    }
    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }
    
    /* --------------------------------
       Reasoning Method UI Improvements
    -------------------------------- */
    .feature-section {
      border: 1px solid #444;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 16px;
      background-color: #2a2a2a;
    }
    
    .feature-header {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .feature-header input[type="checkbox"] {
      margin-right: 8px;
    }
    
    .feature-header label {
      font-weight: 500;
      font-size: 1rem;
    }
    
    .feature-options {
      margin-left: 24px;
      padding-top: 8px;
      border-top: 1px solid #444;
    }
    
    .option-label {
      margin-bottom: 8px;
      color: #bbb;
      font-size: 0.9rem;
    }
    
    .radio-options {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 10px;
    }
    
    .radio-option {
      display: flex;
      align-items: center;
    }
    
    .radio-option input[type="radio"] {
      margin-right: 8px;
      width: auto;
      cursor: pointer;
    }
    
    .radio-option label {
      cursor: pointer;
      margin-bottom: 0;
    }
    
    /* Make radio buttons more visible and clickable */
    input[type="radio"] {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      border: 2px solid #555;
      outline: none;
      margin-right: 8px;
      position: relative;
      cursor: pointer;
    }
    
    input[type="radio"]:checked {
      border-color: #4a8cff;
    }
    
    input[type="radio"]:checked:before {
      content: '';
      position: absolute;
      top: 3px;
      left: 3px;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #4a8cff;
    }
    
    /* Make checkboxes more visible and clickable */
    input[type="checkbox"] {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border: 2px solid #555;
      border-radius: 3px;
      outline: none;
      cursor: pointer;
      position: relative;
    }
    
    input[type="checkbox"]:checked {
      border-color: #4a8cff;
      background-color: #4a8cff;
    }
    
    input[type="checkbox"]:checked:before {
      content: '‚úì';
      position: absolute;
      color: white;
      font-size: 12px;
      top: -1px;
      left: 2px;
    }
    
    .tooltip {
      margin-left: 6px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      background-color: #555;
      border-radius: 50%;
      font-size: 12px;
      cursor: help;
    }

    /* Status notification */
    .status-notification {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background-color: #2a2a2a;
      color: white;
      padding: 10px 15px;
      border-radius: 4px;
      box-shadow: 0 3px 6px rgba(0,0,0,0.3);
      z-index: 1001;
      display: none;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .status-notification.show {
      display: block;
      opacity: 1;
    }
    
    /* Better modal close button */
    .close-modal {
      position: absolute;
      top: 15px;
      right: 15px;
      background: none;
      border: none;
      color: #aaa;
      font-size: 20px;
      cursor: pointer;
      padding: 0;
      margin: 0;
      transition: color 0.2s ease;
    }
    
    .close-modal:hover {
      color: #eee;
    }
    
    /* Current model display */
    .current-model-display {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 4px;
      background-color: #253245;
      color: #fff;
      font-size: 0.9rem;
      margin-left: 10px;
    }
    
    .reasoning-badge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.7rem;
      margin-left: 5px;
      background-color: #444;
    }
    
    /* Two column layout for some settings */
    .settings-row {
      display: flex;
      gap: 20px;
      margin-bottom: 15px;
    }
    
    .settings-column {
      flex: 1;
    }
    
    /* Prompt editing styles */
    .prompt-editor {
      margin-top: 15px;
    }
    
    .prompt-editor textarea {
      width: 100%;
      min-height: 150px;
      background-color: #252525;
      color: #ddd;
      border: 1px solid #444;
      border-radius: 5px;
      padding: 10px;
      font-family: monospace;
      font-size: 0.9rem;
      line-height: 1.4;
      resize: vertical;
    }
    
    .prompt-reset {
      margin-top: 5px;
      font-size: 0.8rem;
      color: #aaa;
      cursor: pointer;
      text-decoration: underline;
    }
    
    .prompt-reset:hover {
      color: #4a8cff;
    }

    /* Enhanced styles for Chain of Draft */
    .cod-thinking {
      background-color: #1e293b !important;
      border-color: #3d4e63 !important;
    }

    .cod-step {
      display: flex;
      align-items: flex-start;
      padding: 6px 8px;
      margin-bottom: 10px !important;
      border-left: none !important;
      background-color: #2c3b4f;
      border-radius: 6px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.2);
    }

    .step-number {
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 24px;
      height: 24px;
      background-color: #3d4f69;
      border-radius: 12px;
      margin-right: 10px;
      color: #a3c5e9;
      font-size: 0.75rem;
      font-weight: bold;
    }

    .step-content {
      flex: 1;
      padding-right: 8px;
      font-family: 'Roboto Mono', monospace;
      color: #c5d5e8;
    }

    /* Enhanced token display */
    .token-savings {
      font-size: 0.7rem;
      color: #4ade80;
      margin-left: 5px;
    }

    /* COD Word Limit options */
    .cod-options {
      margin-top: 15px;
      display: none;
    }

    .cod-word-limit-options {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 15px;
    }

    .cod-word-limit-option {
      display: flex;
      align-items: center;
      padding: 8px 12px;
      margin-bottom: 8px;
      background-color: #2a2a2a;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }

    .cod-word-limit-option:hover {
      background-color: #333;
    }

    .cod-word-limit-option.selected {
      background-color: #3a4a5c;
      border-left: 3px solid #4a8cff;
    }

    .cod-word-limit-value {
      font-weight: bold;
      margin-right: 5px;
    }

    .cod-word-limit-desc {
      font-size: 0.85rem;
      color: #aaa;
    }

    /* CoD examples section */
    .cod-examples {
      margin-top: 15px;
      padding: 15px;
      background-color: #2a2a2a;
      border-radius: 8px;
      border: 1px solid #444;
    }

    .cod-examples-header {
      font-size: 0.9rem;
      font-weight: bold;
      margin-bottom: 10px;
      color: #ddd;
      border-bottom: 1px solid #444;
      padding-bottom: 5px;
    }

    .cod-example-item {
      margin-bottom: 12px;
      font-family: 'Roboto Mono', monospace;
      font-size: 0.85rem;
      padding: 8px;
      background-color: #333;
      border-radius: 5px;
      color: #bbb;
    }

    .cod-example-question {
      color: #aaa;
      margin-bottom: 5px;
    }

    .cod-example-answer {
      color: #4a8cff;
    }
    
    /* Word count breakdown */
    .word-count-breakdown {
      font-size: 0.7rem;
      color: #aaa;
      margin-top: 3px;
      display: flex;
      gap: 8px;
    }

    .count-item {
      display: flex;
      align-items: center;
    }

    .count-thinking {
      color: #b7c9db;
    }

    .count-answer {
      color: #90cdf4;
    }
    
    /* NEW STYLING: Enhanced reasoning features */
    .advanced-options-header {
      font-size: 0.95rem;
      font-weight: 500;
      margin: 15px 0 8px 0;
      color: #ddd;
      border-bottom: 1px solid #444;
      padding-bottom: 5px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 44px;
      height: 22px;
    }
    
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #555;
      transition: .4s;
      border-radius: 22px;
    }
    
    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    
    input:checked + .toggle-slider {
      background-color: #4a8cff;
    }
    
    input:checked + .toggle-slider:before {
      transform: translateX(22px);
    }
    
    .enhanced-reasoning {
      background-color: #2a3746;
      border: 1px solid #3d4e63;
      border-radius: 8px;
      padding: 12px;
      margin-top: 10px;
    }
    
    .enhanced-reasoning-option {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
    }
    
    .enhanced-reasoning-option input[type="radio"] {
      margin-right: 10px;
    }
    
    .option-description {
      margin-left: 25px;
      font-size: 0.8rem;
      color: #aaa;
      margin-bottom: 10px;
    }
    
    .complexity-indicator {
      display: flex;
      margin-top: 15px;
      margin-bottom: 10px;
    }
    
    .complexity-level {
      display: flex;
      flex-direction: column;
      align-items: center;
      flex: 1;
    }
    
    .complexity-bar {
      height: 5px;
      background-color: #3d4e63;
      margin-top: 5px;
      border-radius: 2px;
      width: 100%;
    }
    
    .complexity-label {
      font-size: 0.75rem;
      color: #90cdf4;
    }
    
    .preset-type {
      display: inline-block;
      padding: 3px 8px;
      background-color: #2c3a4f;
      color: #90cdf4;
      border-radius: 12px;
      font-size: 0.7rem;
      margin-left: 8px;
    }
    
    /* Auto-detection indicator */
    .auto-detection-badge {
      display: inline-flex;
      align-items: center;
      background-color: #394e6a;
      color: #a3c5e9;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.7rem;
      margin-left: 7px;
    }
    
    .auto-detection-badge .indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      background-color: #68d391;
      border-radius: 50%;
      margin-right: 4px;
    }
    
    /* Help panel for complex problems */
    .problem-analyzer {
      margin-top: 15px;
      background-color: #2a3746;
      border: 1px solid #3d4e63;
      border-radius: 8px;
      padding: 12px;
    }
    
    .analyzer-title {
      font-weight: 500;
      color: #90cdf4;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
    }
    
    .analyzer-icon {
      margin-right: 6px;
      color: #68d391;
    }
    
    .analyzer-help {
      font-size: 0.85rem;
      color: #bbb;
      margin-bottom: 10px;
      line-height: 1.4;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .app-container {
        flex-direction: column;
      }
      
      .sidebar {
        width: 100%;
        max-height: 200px;
      }
      
      .message {
        max-width: 85%;
      }
      
      .settings-row {
        flex-direction: column;
        gap: 10px;
      }
    }

    /* File Upload Styles */
    .file-upload-button {
      background-color: #3a3a3a;
      color: #fff;
      border: none;
      border-radius: 8px;
      padding: 0.3rem 0.6rem;
      margin-right: 0.5rem;
      cursor: pointer;
      font-size: 0.9rem;
      display: inline-flex;
      align-items: center;
      transition: background-color 0.3s ease;
      box-shadow: 0 1px 3px rgba(0,0,0,0.4);
    }

    .file-upload-button:hover {
      background-color: #4a4a4a;
    }

    .file-upload-icon {
      margin-right: 5px;
    }

    .file-input {
      display: none;
    }

    .attached-files {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      padding: 8px;
      border-top: 1px solid #333;
      background-color: rgba(30,30,30,0.95);
    }

    .file-preview {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #2e2e2e;
      border-radius: 8px;
      padding: 8px;
      max-width: 100px;
    }

    .file-preview-image {
      width: 80px;
      height: 80px;
      object-fit: cover;
      border-radius: 6px;
    }

    .file-preview-icon {
      width: 80px;
      height: 80px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      color: #aaa;
      background-color: #222;
      border-radius: 6px;
    }

    .file-preview-name {
      margin-top: 5px;
      font-size: 0.7rem;
      text-align: center;
      width: 100%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      color: #ddd;
    }

    .file-preview-remove {
      position: absolute;
      top: 0;
      right: 0;
      background-color: rgba(0, 0, 0, 0.6);
      color: #fff;
      border: none;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      font-size: 0.7rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .message-file-attachment {
      margin-top: 10px;
      padding: 10px;
      background-color: #2a2a2a;
      border-radius: 6px;
      display: flex;
      align-items: center;
    }

    .message-file-icon {
      margin-right: 10px;
      font-size: 1.2rem;
      color: #aaa;
    }

    .message-file-info {
      display: flex;
      flex-direction: column;
    }

    .message-file-name {
      font-size: 0.85rem;
      font-weight: 500;
    }

    .message-file-size {
      font-size: 0.7rem;
      color: #aaa;
    }

    .message-image {
      max-width: 100%;
      border-radius: 6px;
      margin-top: 10px;
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .message-image:hover {
      transform: scale(1.01);
    }

    /* Add new self-reflection CSS */
    .reflection-step {
      background-color: #3d4661 !important;
      border-left: 3px solid #8a5cf7 !important;
    }

    .reflection-step .step-number {
      background-color: #5d4d8a !important;
      color: #d4c5ff !important;
    }

    .reflection-step .step-content {
      color: #d4c5ff !important;
      font-style: italic;
    }

    /* Simplified Parameters Tab */
    .range-container {
      position: relative;
      margin-bottom: 20px;
    }

    .range-value {
      position: absolute;
      right: 0;
      top: 0;
      font-size: 0.9rem;
      color: #aaa;
    }

    /* Ensure submit button and clear thread are more visible */
    #sendBtn, #clearThreadBtn {
      background-color: #4a8cff;
      color: white;
      padding: 8px 15px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-weight: 500;
      transition: background-color 0.2s;
    }

    #sendBtn:hover, #clearThreadBtn:hover {
      background-color: #357abd;
    }

    #clearThreadBtn {
      background-color: #dc3545;
      width: 100%;
      margin-top: 10px;
    }

    #clearThreadBtn:hover {
      background-color: #bd2130;
    }
  </style><style class="darkreader darkreader--sync" media="screen"></style>
<meta name="darkreader" content="dbb61675415b4944b93830950218de1d"><style class="darkreader darkreader--override" media="screen">.vimvixen-hint {
    background-color: var(--darkreader-background-ffd76e, #684b00) !important;
    border-color: var(--darkreader-background-c59d00, #9e7e00) !important;
    color: var(--darkreader-text-302505, #d7d4cf) !important;
}
#vimvixen-console-frame {
    color-scheme: light !important;
}
::placeholder {
    opacity: 0.5 !important;
}
#edge-translate-panel-body,
.MuiTypography-body1,
.nfe-quote-text {
    color: var(--darkreader-neutral-text) !important;
}
gr-main-header {
    background-color: var(--darkreader-background-add8e6, #1b4958) !important;
}
.tou-z65h9k,
.tou-mignzq,
.tou-1b6i2ox,
.tou-lnqlqk {
    background-color: var(--darkreader-neutral-background) !important;
}
.tou-75mvi {
    background-color: var(--darkreader-background-cfecf5, #0f3a47) !important;
}
.tou-ta9e87,
.tou-1w3fhi0,
.tou-1b8t2us,
.tou-py7lfi,
.tou-1lpmd9d,
.tou-1frrtv8,
.tou-17ezmgn {
    background-color: var(--darkreader-background-f5f5f5, #1e2021) !important;
}
.tou-uknfeu {
    background-color: var(--darkreader-background-faedda, #432c09) !important;
}
.tou-6i3zyv {
    background-color: var(--darkreader-background-85c3d8, #245d70) !important;
}
div.mermaid-viewer-control-panel .btn {
    background-color: var(--darkreader-neutral-background);
    fill: var(--darkreader-neutral-text);
}
svg g rect.er {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.entityBox {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.attributeBoxOdd {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.attributeBoxEven {
    fill: var(--darkreader-selection-background);
    fill-opacity: 0.8 !important;
}
svg rect.er.relationshipLabelBox {
    fill: var(--darkreader-neutral-background) !important;
}
svg g g.nodes rect,
svg g g.nodes polygon {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.task {
    fill: var(--darkreader-selection-background) !important;
}
svg line.messageLine0,
svg line.messageLine1 {
    stroke: var(--darkreader-neutral-text) !important;
}
div.mermaid .actor {
    fill: var(--darkreader-neutral-background) !important;
}
mitid-authenticators-code-app > .code-app-container {
    background-color: white !important;
    padding-top: 1rem;
}
iframe#unpaywall[src$="unpaywall.html"] {
    color-scheme: light !important;
}
select option {
    background-color: var(--darkreader-neutral-background) !important;
}
body#tumblr {
    --darkreader-bg--secondary-accent: 31, 32, 34 !important;
    --darkreader-bg--white: 23, 23, 23 !important;
    --darkreader-text--black: 228, 224, 218 !important;
}
:host {
    --d2l-border-color: var(--darkreader-bg--d2l-color-gypsum) !important;
    --d2l-button-icon-background-color-hover: var(--darkreader-bg--d2l-color-gypsum) !important;
    --d2l-color-ferrite: var(--darkreader-neutral-text) !important;
    --d2l-color-sylvite: var(--darkreader-bg--d2l-color-sylvite) !important;
    --d2l-dropdown-background-color: var(--darkreader-neutral-background) !important;
    --d2l-dropdown-border-color: var(--darkreader-border--d2l-color-mica) !important;
    --d2l-input-backgroud-color: var(--darkreader-neutral-background) !important;
}
:host([_floating]) .d2l-floating-buttons-container {
    background-color: var(--darkreader-neutral-background) !important;
    border-top-color: var(--darkreader-border--d2l-color-mica) !important;
    opacity: 0.88 !important;
}
d2l-card {
    background: var(--darkreader-neutral-background) !important;
    border-color: var(--darkreader-border--d2l-color-gypsum) !important;
}
d2l-dropdown-content > div,
d2l-menu-item {
    background-color: var(--darkreader-neutral-background) !important;
    border-radius: 10px !important;
}
d2l-empty-state-simple {
    border-color: var(--darkreader-bg--d2l-color-gypsum) !important;
}
.d2l-button-filter > ul > li > a.vui-button {
    border-color: var(--darkreader-border--d2l-color-mica) !important;
}
.d2l-label-text:has(.d2l-button-subtle-content):hover,
.d2l-label-text:has(.d2l-button-subtle-content):focus,
.d2l-label-text:has(.d2l-button-subtle-content):active {
    background-color: var(--darkreader-bg--d2l-color-gypsum) !important;
}
.d2l-navigation-centerer {
    color: inherit !important;
}
.d2l-tabs-layout {
    border-color: var(--darkreader-border--d2l-color-gypsum) !important;
}
.d2l-input,
.d2l-calendar-date,
.d2l-htmleditor-container {
    background-color: var(--darkreader-neutral-background) !important;
}
.d2l-collapsible-panel {
    border: 1px solid var(--darkreader-border--d2l-color-mica) !important;
    border-radius: 0.4rem !important;
}
.d2l-collapsible-panel-divider {
    border-bottom: 1px solid var(--darkreader-border--d2l-color-mica) !important;
}
.d2l-w2d-flex {
    border-bottom: 2px solid var(--darkreader-border--d2l-color-mica) !important;
}
.d2l-collapsible-panel scrolled,
.d2l-collapsible-panel-header,
.d2l-w2d-collection-fixed {
    background-color: var(--darkreader-neutral-background) !important;
}
.d2l-loading-spinner-bg {
    fill: var(--darkreader-bg--d2l-color-gypsum) !important;
}
.d2l-loading-spinner-bg-stroke {
    stroke: var(--darkreader-border--d2l-color-mica) !important;
}
.d2l-loading-spinner-wrapper svg path,
.d2l-loading-spinner-wrapper svg circle {
    fill: var(--darkreader-neutral-background) !important;
}
embed[type="application/pdf"][src="about:blank"] { filter: invert(100%) contrast(90%); }</style><style id="dark-reader-style" type="text/css">@media screen {
html {-webkit-transition : -webkit-filter 300ms linear;}
}</style><style class="darkreader darkreader--sync" media="screen"></style></head>
<body>
  <div id="blue-light-blocker-overlay" style="position: fixed; top: 0px; left: 0px; width: 100%; height: 100%; z-index: 2147483647; pointer-events: none; transition: opacity 0.3s; mix-blend-mode: multiply; background-color: rgb(255, 175, 50); opacity: 0; --darkreader-inline-bgcolor: var(--darkreader-background-ffaf32, #ae6a00);" data-darkreader-inline-bgcolor=""></div><!-- Include jsPDF for PDF generation -->
  <script src="./LLM Playground (COT vs COD)_files/jspdf.umd.min.js"></script>

  <div class="app-container">
    <!-- Sidebar for Thread Management -->
    <div class="sidebar">
      <h2>Threads</h2>
      <ul id="threadList"><li class="active">Thread 1</li></ul>
      <button id="newThreadBtn">New Thread</button>
      <button id="deleteThreadBtn">Delete Thread</button>
      <button id="downloadTxtBtn">Download TXT</button>
      <button id="downloadPdfBtn">Download PDF</button>
    <button id="clearThreadBtn" style="margin-top: 0.5rem; background-color: rgb(85, 51, 51); --darkreader-inline-bgcolor: var(--darkreader-background-553333, #442929);" data-darkreader-inline-bgcolor="">Clear Thread</button></div>

    <!-- Chat Area -->
    <div class="chat-container">
      <div class="chat-header">
        <h1 id="pageTitle">LLM Playground (COT vs COD)</h1>
        <div>
          <span id="currentModelDisplay" class="current-model-display">llama-3.3-70b<span class="reasoning-badge" style="background-color: #2d5038; margin-left: 3px;">Adaptive</span></span>
          <button class="settings-btn" id="openSettings">Settings ‚öôÔ∏è</button>
        </div>
      </div>
      <div class="chat-messages" id="chatMessages"></div>
      <div class="chat-input">
        <textarea id="userInput" rows="2" placeholder="Type your message..."></textarea>
        <button id="sendBtn">Send</button>
        <label for="fileInput" class="file-upload-button">
          <span class="file-upload-icon">üìé</span>
          Attach
        </label>
        <input type="file" id="fileInput" class="file-input" multiple="">
      </div>
      <div id="attachedFiles" class="attached-files" style="display: none;"></div>
    </div>
  </div>

  <!-- Status Notification -->
  <div id="statusNotification" class="status-notification">TXT file downloaded</div>

  <!-- Settings Modal -->
<div id="settingsModal" class="modal" style="display: none;">
  <div class="modal-content">
    <button class="close-modal" id="closeModalX">√ó</button>
    <h2>Settings</h2>
    
    <div class="settings-tabs">
      <button class="tab-btn" data-tab="modelTab">Model</button>
      <button class="tab-btn" data-tab="reasoningTab">Reasoning</button>
      <button class="tab-btn active" data-tab="parametersTab">Parameters</button>
    </div>
    
    <!-- Model Selection Tab -->
    <div id="modelTab" class="tab-content" style="display: none;">
      <div class="settings-section-header">Model Selection</div>

      <label for="modelSelect">Select LLM Model</label>
      <div class="model-select-container">
        <select id="modelSelect" class="model-dropdown">
          <option value="" disabled="" selected="">Choose a model...</option>
          
          
          
       <option value="qwen-2.5-coder-32b">Qwen 2.5 Coder (32B)</option><option value="llama-3.3-70b-versatile">Llama 3.3 (70B)</option><option value="mixtral-8x7b-32768">Mixtral 8x7B</option></select>
        <div class="dropdown-arrow">‚ñº</div>
      </div>

      <div class="model-info-card" id="modelInfoCard" style="display: block; opacity: 1; transform: translateY(0px); transition: opacity 0.3s, transform 0.3s;">
        <div class="model-info-header">
          <span id="selectedModelName">Llama 3.3 (70B)</span>
        </div>
        <div class="model-info-body">
          <div class="model-tags" id="modelTags"><span class="model-tag">70B</span><span class="model-tag">Versatile</span><span class="model-tag">Advanced</span></div>
          <div class="model-description" id="modelDescription">Meta's Llama 3.3 70B model offering strong performance across a wide range of tasks with advanced reasoning capabilities.</div>
        </div>
      </div>

      <button id="setModelBtn">Set Model</button>
    </div>
    
    <!-- Reasoning Tab -->
    <div id="reasoningTab" class="tab-content" style="display: none;">
      <div class="settings-section-header">Reasoning Method</div>
      <div class="feature-section">
        <div class="radio-options">
          <div class="radio-option">
            <input type="radio" id="standardReasoning" name="reasoningMethod" value="standard">
            <label for="standardReasoning">Standard (No special prompt)</label>
            <div class="tooltip">?
              <span class="tooltiptext">Default model behavior with no special reasoning instructions.</span>
            </div>
          </div>
          
          <div class="radio-option">
            <input type="radio" id="cotReasoning" name="reasoningMethod" value="cot">
            <label for="cotReasoning">Chain of Thought (CoT)</label>
            <div class="tooltip">?
              <span class="tooltiptext">Instructs the model to think step-by-step to solve problems. Improves reasoning but uses more tokens.</span>
            </div>
          </div>
          
          <div class="radio-option">
            <input type="radio" id="codReasoning" name="reasoningMethod" value="cod" checked="">
            <label for="codReasoning">Chain of Draft (CoD)</label>
            <div class="tooltip">?
              <span class="tooltiptext">Uses minimal words per step (research paper approach) to reduce token usage while maintaining reasoning quality.</span>
            </div>
          </div>
        </div>
        
        <!-- COD Word Limit options -->
        <div id="codOptions" class="cod-options" style="display: none;">
        <div class="option-label">Word limit per step:</div>
        <div class="cod-word-limit-options">
          <div class="cod-word-limit-option " data-value="5">
            <span class="cod-word-limit-value">5 words</span>
            <span class="cod-word-limit-desc">Original paper recommendation</span>
          </div>
          <div class="cod-word-limit-option " data-value="10">
            <span class="cod-word-limit-value">10 words</span>
            <span class="cod-word-limit-desc">Balanced brevity and clarity</span>
          </div>
          <div class="cod-word-limit-option " data-value="15">
            <span class="cod-word-limit-value">15 words</span>
            <span class="cod-word-limit-desc">More descriptive steps</span>
          </div>
          <div class="cod-word-limit-option " data-value="17">
            <span class="cod-word-limit-value">17 words</span>
            <span class="cod-word-limit-desc">Better for complex reasoning</span>
          </div>
          <div class="cod-word-limit-option selected" data-value="20">
            <span class="cod-word-limit-value">20 words</span>
            <span class="cod-word-limit-desc">Detailed steps for math &amp; logic</span>
          </div>
        </div>
        
        <div class="cod-examples">
          <div class="cod-examples-header">Chain of Draft Example</div>
          <div class="cod-example-item">
            <div class="cod-example-question">Q: If a fabric store received 45 yards of cotton and used 2/9 of it, how many yards remain?</div>
            <div class="cod-example-answer">A: Total: 45 yards. Used: 2/9 √ó 45 = 10 yards. Remaining: 45 - 10 = 35 yards. #### 35 yards</div>
          </div>
        </div>
      </div>
      </div>
      
      <!-- NEW: Enhanced Reasoning Controls -->
      <div class="advanced-options-header">
        Advanced Reasoning Options
        <label class="toggle-switch">
          <input type="checkbox" id="enhancedReasoningToggle" checked="">
          <span class="toggle-slider"></span>
        </label>
      </div>
      
      <div id="enhancedReasoningOptions" class="enhanced-reasoning" style="display: block;">
        <div class="enhanced-reasoning-option">
          <input type="radio" id="adaptiveReasoning" name="reasoningEnhancement" value="adaptive" checked="">
          <label for="adaptiveReasoning">Adaptive Reasoning</label>
          <span class="auto-detection-badge"><span class="indicator"></span>Auto</span>
        </div>
        <div class="option-description">
          Automatically increases reasoning depth for complex problems (math, logic, multi-step reasoning).
        </div>
        
        <div class="enhanced-reasoning-option">
          <input type="radio" id="standardReasoning" name="reasoningEnhancement" value="standard">
          <label for="standardReasoning">Fixed Reasoning Depth</label>
        </div>
        <div class="option-description">
          Uses the same reasoning approach for all problems regardless of complexity.
        </div>
        
        <div class="problem-analyzer">
          <div class="analyzer-title">
            <span class="analyzer-icon">üîç</span> Problem Complexity Detection
          </div>
          <div class="analyzer-help">
            When adaptive reasoning is enabled, the system will automatically analyze your questions to detect:
            <ul style="margin-top: 5px; padding-left: 20px; font-size: 0.85rem;">
              <li>Mathematical expressions and calculations</li>
              <li>Multi-step reasoning requirements</li>
              <li>Logical dependencies and constraints</li>
              <li>Complex or abstract concepts</li>
            </ul>
            For complex problems, the model will use more detailed reasoning steps even with CoD.
          </div>
        </div>
      </div>

      <!-- Replace Self-Consistency Section with Self-Reflection -->
      <div class="advanced-options-header">
        Self-Reflection for Chain of Draft
        <label class="toggle-switch">
          <input type="checkbox" id="selfReflectionToggle" checked>
          <span class="toggle-slider"></span>
        </label>
      </div>

      <div id="selfReflectionInfo" class="enhanced-reasoning" style="display: block;">
        <div class="option-description">
          Adds a reflection step after reasoning to help the model verify its own work and catch mistakes.
        </div>
        
        <div class="problem-analyzer">
          <div class="analyzer-title">
            <span class="analyzer-icon">üîç</span> How Self-Reflection Works
          </div>
          <div class="analyzer-help">
            When using Chain of Draft with self-reflection:
            <ul style="margin-top: 5px; padding-left: 20px; font-size: 0.85rem;">
              <li>The model reasons step-by-step as usual</li>
              <li>Before concluding, it adds a reflection step to check for errors</li>
              <li>This helps identify calculation mistakes, misunderstandings, or logic errors</li>
              <li>The reflection is highlighted in the UI for easy identification</li>
            </ul>
            This approach improves accuracy with a single API call, unlike self-consistency which required multiple calls.
          </div>
        </div>
      </div>
    </div>
    
    <!-- Parameters Tab -->
    <div id="parametersTab" class="tab-content active">
      <div class="settings-section-header">Generation Parameters</div>
      
      <label for="temp">Temperature</label>
      <div class="range-container">
        <input type="range" id="temp" min="0" max="1" step="0.01" value="0.5">
        <span id="tempValue" class="range-value">0.5</span>
      </div>
      <p style="font-size: 0.8rem; color: #aaa; margin-top: 0;">Controls randomness: lower values make responses more focused.</p>

      <label for="topP">Top P</label>
      <div class="range-container">
        <input type="range" id="topP" min="0" max="1" step="0.01" value="0.90">
        <span id="topPValue" class="range-value">0.9</span>
      </div>
      <p style="font-size: 0.8rem; color: #aaa; margin-top: 0;">Controls diversity via nucleus sampling.</p>

      <label for="maxTokens">Max Tokens</label>
      <div class="range-container">
        <input type="range" id="maxTokens" min="256" max="4096" step="128" value="1112">
        <span id="maxTokensValue" class="range-value">1152</span>
      </div>
      <p style="font-size: 0.8rem; color: #aaa; margin-top: 0;">Maximum length of the response.</p>
    </div>
    
    <div style="text-align: right; margin-top: 20px;">
      <button id="saveSettings">Save</button>
      <button id="closeSettings">Cancel</button>
    </div>
  </div>
</div>

  <!-- Feedback Button and Modal -->
  <div style="position: fixed; bottom: 20px; left: 20px; z-index: 1000;">
    <button id="openFeedbackBtn" style="background-color: rgb(74, 140, 255); color: white; border: none; padding: 10px 15px; border-radius: 20px; cursor: pointer; box-shadow: rgba(0, 0, 0, 0.3) 0px 2px 5px; --darkreader-inline-bgcolor: var(--darkreader-background-4a8cff, #003aa0); --darkreader-inline-color: var(--darkreader-text-ffffff, #e8e6e3); --darkreader-inline-border-top: none; --darkreader-inline-border-right: none; --darkreader-inline-border-bottom: none; --darkreader-inline-border-left: none; --darkreader-inline-boxshadow: var(--darkreader-background-0000004d, rgba(0, 0, 0, 0.3)) 0px 2px 5px;" data-darkreader-inline-bgcolor="" data-darkreader-inline-color="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-boxshadow="">
      <span style="margin-right: 5px;">üí¨</span> Feedback
    </button>
  </div>

  <div id="feedbackModal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 500px;">
      <button class="close-modal" id="closeFeedbackModal">√ó</button>
      <h2>Share Your Feedback</h2>
      
      <form method="POST" name="feedback">
        <input type="hidden" name="form-name" value="feedback">
        
        <input type="hidden" id="feedbackModel" name="model" value="qwen-2.5-coder">
        <input type="hidden" id="feedbackReasoning" name="reasoning_method" value="COD-20">
        
        <label for="feedbackType">Feedback Type:</label>
        <select id="feedbackType" name="feedback_type" style="width: 100%; margin-bottom: 15px;">
          <option value="general">General Feedback</option>
          <option value="bug">Report a Bug</option>
          <option value="feature">Feature Request</option>
          <option value="model_performance">Model Performance</option>
        </select>
        
        <label>How would you rate your experience?</label>
        <div style="display: flex; justify-content: space-between; margin: 10px 0 15px 0;">
          <label style="flex: 1; text-align: center;">
            <input type="radio" name="rating" value="1" required="">
            <div>üòû</div>
            <div style="font-size: 0.8rem;">Poor</div>
          </label>
          <label style="flex: 1; text-align: center;">
            <input type="radio" name="rating" value="2">
            <div>üòê</div>
            <div style="font-size: 0.8rem;">Fair</div>
          </label>
          <label style="flex: 1; text-align: center;">
            <input type="radio" name="rating" value="3">
            <div>üôÇ</div>
            <div style="font-size: 0.8rem;">Good</div>
          </label>
          <label style="flex: 1; text-align: center;">
            <input type="radio" name="rating" value="4">
            <div>üòÄ</div>
            <div style="font-size: 0.8rem;">Great</div>
          </label>
          <label style="flex: 1; text-align: center;">
            <input type="radio" name="rating" value="5">
            <div>ü§©</div>
            <div style="font-size: 0.8rem;">Excellent</div>
          </label>
        </div>
        
        <label for="feedbackComments">Comments:</label>
        <textarea id="feedbackComments" name="comments" rows="4" style="width: 100%; background-color: rgb(46, 46, 46); color: rgb(255, 255, 255); border: 1px solid rgb(68, 68, 68); border-radius: 5px; padding: 10px; margin-bottom: 20px; --darkreader-inline-bgcolor: var(--darkreader-background-2e2e2e, #232627); --darkreader-inline-color: var(--darkreader-text-ffffff, #e8e6e3); --darkreader-inline-border-top: var(--darkreader-border-444444, #766d61); --darkreader-inline-border-right: var(--darkreader-border-444444, #766d61); --darkreader-inline-border-bottom: var(--darkreader-border-444444, #766d61); --darkreader-inline-border-left: var(--darkreader-border-444444, #766d61);" required="" data-darkreader-inline-bgcolor="" data-darkreader-inline-color="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left=""></textarea>
        
        <button type="submit" style="background-color: rgb(74, 140, 255); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; float: right; --darkreader-inline-bgcolor: var(--darkreader-background-4a8cff, #003aa0); --darkreader-inline-color: var(--darkreader-text-ffffff, #e8e6e3); --darkreader-inline-border-top: none; --darkreader-inline-border-right: none; --darkreader-inline-border-bottom: none; --darkreader-inline-border-left: none;" data-darkreader-inline-bgcolor="" data-darkreader-inline-color="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="">
          Submit Feedback
        </button>
      </form>
    </div>
  </div>

  <script>
    /***********************
     * Global Configuration
     ***********************/
    let MODEL_NAME = "";
    let MODEL_NAME_DISPLAY = "";
    
    // Server endpoint (Netlify serverless function)
    const API_PROXY_URL = "/.netlify/functions/api-proxy";
    
    // Reasoning Method
    let REASONING_METHOD = "cod"; // Options: "standard", "cot", "cod"
    
    // COD Word Limit
    let COD_WORD_LIMIT = 5;
    
    // NEW: Enhanced reasoning controls
    let ENHANCED_REASONING_ENABLED = true;
    let REASONING_ENHANCEMENT = "adaptive"; // Options: "adaptive", "standard"
    
    // NEW: Problem complexity detection
    let PROBLEM_COMPLEXITY = {
      hasMath: false,
      hasLogic: false,
      multiStep: false,
      complexity: "normal" // Options: "simple", "normal", "complex"
    };
    
    // Prompts for different reasoning methods
    let PROMPTS = {
      standard: "",
      
      cot: `Think step by step to solve this problem. Explain your reasoning at each step, then provide your final answer.`,
      
      cod: `Think step by step, but produce only minimal notes for each step (${COD_WORD_LIMIT} words maximum per step). Use mathematical notation where possible. Keep only essential information needed to solve the problem. Focus on key calculations and intermediate results without narrative explanation.
  
Separate your steps with periods. Write your final answer after the #### separator.

Examples:
Q: Jason had 20 lollipops. He gave Denny some lollipops. Now Jason has 12 lollipops. How many lollipops did Jason give to Denny?
A: 20 initial. 12 remaining. 20 - 12 = 8. #### 8 lollipops

Q: Roger has $125. He spends $55 on a video game and then receives $25 for his birthday. How much money does Roger have now?
A: Start: $125. Spent: $55. 125 - 55 = $70. Received: $25. 70 + 25 = $95. #### $95

Q: A square has a perimeter of 20 cm. What is its area?
A: Perimeter = 20 cm. Side length = 20/4 = 5 cm. Area = 5¬≤ = 25 cm¬≤. #### 25 square centimeters

Q: If a fabric store received 45 yards of cotton material and used 2/9 of it for a bulk order, how many yards of cotton material does the fabric store have left?
A: Total: 45 yards. Used: 2/9 √ó 45 = 10 yards. Remaining: 45 - 10 = 35 yards. #### 35 yards

Q: The temperature on Monday was -3¬∞C. On Tuesday, it was 14¬∞C. What was the change in temperature from Monday to Tuesday?
A: Monday: -3¬∞C. Tuesday: 14¬∞C. Change: 14 - (-3) = 17¬∞C. #### 17¬∞C`
    };
    
    // NEW: Enhanced prompts for complex problems with different word limits
    let ENHANCED_PROMPTS = {
      cot: `Think step by step to solve this problem. This appears to be a complex problem that requires careful reasoning. Break down your thinking into clear steps, making sure to consider all relevant information and constraints. 

For complex problems, use as many steps as needed to work through the solution thoroughly. It's better to use more steps with clear reasoning than to skip steps.

Check your calculations and logic at each step. After you've completed your reasoning process, provide your final answer.`,
      
      cod5: `Think step by step to solve this complex problem. For each step, use at most 5 words to capture the essential reasoning, but use AS MANY STEPS as needed to thoroughly work through the problem. Use mathematical notation where efficient. Show ALL intermediate calculations and logical inferences.

IMPORTANT: Instead of trying to fit complex reasoning into fewer steps, break your reasoning into more numerous simple steps. For example, instead of one step with "Calculate area using length√ówidth=50√ó30=1500", use multiple steps:
1. Length = 50.
2. Width = 30.
3. Area = length √ó width.
4. Area = 50 √ó 30.
5. Area = 1500.

Separate your steps with periods. Write your final answer after the #### separator.

Example of solving a complex problem with sufficient steps:
Q: A car travels at 60 mph. After 2 hours, it increases speed to 75 mph for 1 hour. It then decreases to 50 mph for the final 30 minutes. What is the total distance traveled?
A: First segment: speed 60 mph. First segment: time 2h. First segment: distance = 60 √ó 2. First segment: distance = 120 miles. Second segment: speed 75 mph. Second segment: time 1h. Second segment: distance = 75 √ó 1. Second segment: distance = 75 miles. Third segment: speed 50 mph. Third segment: time 0.5h. Third segment: distance = 50 √ó 0.5. Third segment: distance = 25 miles. Total distance: 120 + 75 + 25. Total distance = 220 miles. #### 220 miles`,

      cod10: `Think step by step to solve this complex problem. For each step, use up to 10 words to capture the essential reasoning. Use AS MANY STEPS as needed to fully solve the problem. Include ALL intermediate calculations and logical inferences.

IMPORTANT: For complex problems, it's better to use more steps with clear reasoning than to try cramming too much into each step. Break complex calculations into multiple steps.

When thinking through difficult parts of a problem:
1. Identify what information you need
2. Think about how to derive that information
3. Perform calculations systematically
4. Check your work at key points

Separate your steps with periods. Write your final answer after the #### separator.

Example of solving a complex problem:
Q: A car travels at 60 mph. After 2 hours, it increases speed to 75 mph for 1 hour. It then decreases to 50 mph for the final 30 minutes. What is the total distance traveled?
A: First segment: speed 60 mph for 2 hours. First segment distance calculation: 60 mph √ó 2h. First segment distance = 120 miles. Second segment: speed 75 mph for 1 hour. Second segment distance calculation: 75 mph √ó 1h. Second segment distance = 75 miles. Third segment: speed 50 mph for 0.5 hours. Third segment distance calculation: 50 mph √ó 0.5h. Third segment distance = 25 miles. Need to sum all segment distances. Total distance calculation: 120 + 75 + 25. Total distance traveled = 220 miles. #### 220 miles`,
      
      cod15: `Think step by step to solve this complex problem. For each step, use up to 15 words to capture the essential reasoning, providing more detail for critical steps. Use mathematical notation where helpful but include explanations of your approach at key points.

Separate your steps with periods. Write your final answer after the #### separator.

Example of solving a complex problem:
Q: A car travels at 60 mph. After 2 hours, it increases speed to 75 mph for 1 hour. It then decreases to 50 mph for the final 30 minutes. What is the total distance traveled?
A: First segment: The car travels at 60 mph for 2 hours, so distance = 60 √ó 2 = 120 miles. Second segment: The car increases to 75 mph for 1 hour, so distance = 75 √ó 1 = 75 miles. Third segment: The car decreases to 50 mph for 0.5 hours, so distance = 50 √ó 0.5 = 25 miles. Total distance traveled = 120 + 75 + 25 = 220 miles. #### 220 miles`,
      
      cod17: `Think step by step to solve this complex problem. For each step, use up to 17 words to provide clear reasoning, especially for difficult parts. Balance precision and concision, using math notation to save words.

Separate your steps with periods. Write your final answer after the #### separator.

Example of solving a complex problem:
Q: A car travels at 60 mph. After 2 hours, it increases speed to 75 mph for 1 hour. It then decreases to 50 mph for the final 30 minutes. What is the total distance traveled?
A: First segment: The car travels at 60 mph for 2 hours, giving distance = 60 √ó 2 = 120 miles. Second segment: Speed increases to 75 mph for 1 hour, so this segment's distance = 75 miles. Third segment: Speed is 50 mph for 0.5 hours, contributing 50 √ó 0.5 = 25 miles. Total journey distance = 120 + 75 + 25 = 220 miles. #### 220 miles`,
      
      cod20: `Think step by step to solve this complex problem. For each step, use up to 20 words to provide clear reasoning, explaining your approach more thoroughly for the difficult parts of the problem.

Separate your steps with periods. Write your final answer after the #### separator.

Example of solving a complex problem:
Q: A car travels at 60 mph. After 2 hours, it increases speed to 75 mph for 1 hour. It then decreases to 50 mph for the final 30 minutes. What is the total distance traveled?
A: First segment: The car travels at 60 mph for 2 hours, so the distance covered in this segment is 60 √ó 2 = 120 miles. Second segment: The car then increases speed to 75 mph and maintains this for 1 hour, covering 75 √ó 1 = 75 miles. Third segment: Finally, the car decreases speed to 50 mph for 30 minutes (0.5 hours), covering 50 √ó 0.5 = 25 miles. Total distance traveled over the entire journey = 120 + 75 + 25 = 220 miles. #### 220 miles`
    };
    
    // Default generation parameters
    let TEMPERATURE = 0.5;
    let TOP_P = 0.90;
    let MAX_TOKENS = 1112;

    
    /***********************
     * Thread Management
     ***********************/
    let threads = [];
    let currentThreadId = null;
    let threadCounter = 1;

    function createNewThread() {
      const newThread = {
        id: Date.now(),
        name: `Thread ${threadCounter++}`,
        messages: []
      };
      threads.push(newThread);
      currentThreadId = newThread.id;
      updateThreadList();
      renderCurrentThreadMessages();
      
      // Show status notification
      showNotification("New thread created");
    }

    function updateThreadList() {
      const threadList = document.getElementById("threadList");
      threadList.innerHTML = "";
      threads.forEach(thread => {
        const li = document.createElement("li");
        li.textContent = thread.name;
        if (thread.id === currentThreadId) {
          li.classList.add("active");
        }
        li.addEventListener("click", () => {
          currentThreadId = thread.id;
          renderCurrentThreadMessages();
          updateThreadList();
        });
        threadList.appendChild(li);
      });
    }

    function deleteCurrentThread() {
      if (!currentThreadId) return;
      if (confirm("Are you sure you want to delete this thread?")) {
        threads = threads.filter(thread => thread.id !== currentThreadId);
        if (threads.length > 0) {
          currentThreadId = threads[0].id;
        } else {
          createNewThread();
          return;
        }
        updateThreadList();
        renderCurrentThreadMessages();
        showNotification("Thread deleted");
      }
    }

    /************************************************
     * Helper: Parse Content for Export
     ************************************************/
    function parseContentForExport(content) {
      const result = [];
      const segments = content.split(/```/);
      for (let i = 0; i < segments.length; i++) {
        if (i % 2 === 0) {
          // Normal text
          const textLines = segments[i].split(/\r?\n/);
          textLines.forEach(line => {
            result.push({ type: 'text', content: line });
          });
        } else {
          // Code block
          const codeSegment = segments[i].trim();
          const firstNewlineIndex = codeSegment.index('\n');
          let language = '';
          let codeContent = codeSegment;
          if (firstNewlineIndex !== -1) {
            const possibleLang = codeSegment.substring(0, firstNewlineIndex).trim();
            if (possibleLang && !possibleLang.includes(' ')) {
              language = possibleLang;
              codeContent = codeSegment.substring(firstNewlineIndex + 1);
            }
          }
          const codeLines = codeContent.split(/\r?\n/);
          result.push({ type: 'code', language: language, content: codeLines });
        }
      }
      return result;
    }

    /***********************
     * Word Counting Utility - IMPROVED FOR COD
     ***********************/
    function countWords(text) {
      // Remove code blocks to get more accurate word count for actual text
      const textWithoutCode = text.replace(/```[\s\S]*?```/g, '');
      
      // Count mathematical expressions as single words
      // First, replace common math expressions with placeholder words
      let processedText = textWithoutCode
        // Replace simple equations (e.g., "x = 5 + 3") with single tokens
        .replace(/\b\w+\s*=\s*[\d\w+\-*/()]+/g, "EQUATION")
        // Replace fractions (e.g., "2/3") with single tokens
        .replace(/\b\d+\/\d+\b/g, "FRACTION")
        // Replace mathematical operations with spaces
        .replace(/[+\-*/=<>]+/g, " ");
      
      // Split by whitespace and filter out empty strings
      const words = processedText.split(/\s+/).filter(word => word.length > 0);
      return words.length;
    }

    /***********************
     * NEW: Problem Complexity Analysis
     ***********************/
    function analyzeProblemComplexity(message) {
      // Reset current complexity
      PROBLEM_COMPLEXITY = {
        hasMath: false,
        hasLogic: false,
        multiStep: false,
        complexity: "normal",
        wordCount: message.split(/\s+/).length, // Count words in the problem
        estimatedSteps: 0 // Will be calculated below
      };
      
      // Mathematical expressions and calculations
      const mathPatterns = [
        /[0-9\s][\+\-\*\/\=\(\)][0-9\s]/,  // Basic operations
        /\d+\s*\^\s*\d+/,                  // Powers
        /\d+\s*\/\s*\d+/,                  // Fractions
        /(?:sin|cos|tan|log|ln|sqrt|exp)/i, // Math functions
        /\[\s*[^\]]+\s*\]/,                // Matrix notation
        /\{\s*[^\}]+\s*\}/,                // Set notation
        /[\+\-]\s*[\d\.]+[eE][\+\-]\d+/,   // Scientific notation
        /\d+\s*%/,                         // Percentages
      ];
      
      // Logical expressions
      const logicPatterns = [
        /(?:if|then|else|therefore|because|implies|since|hence|thus|consequently)/i,
        /(?:and|or|not|xor|nor|all|some|every|any|none)/i,
        /(?:true|false|valid|invalid|prove|QED|contradiction|logical|premise|conclusion)/i,
      ];
      
      // Indicators of multi-step problems
      const multiStepPatterns = [
        /(?:first|second|third|next|then|after|finally|lastly|step|phase)/i,
        /(?:find the total|calculate the|determine the|solve for)/i,
        /(?:per month|per year|initially|eventually|ultimately|before|after)/i,
        /(?:increases by|decreases by|changes by|grows|reduces)/i,
      ];
      
      // Check for math patterns
      for (const pattern of mathPatterns) {
        if (pattern.test(message)) {
          PROBLEM_COMPLEXITY.hasMath = true;
          break;
        }
      }
      
      // Check for logic patterns
      for (const pattern of logicPatterns) {
        if (pattern.test(message)) {
          PROBLEM_COMPLEXITY.hasLogic = true;
          break;
        }
      }
      
      // Check for multi-step patterns
      for (const pattern of multiStepPatterns) {
        if (pattern.test(message)) {
          PROBLEM_COMPLEXITY.multiStep = true;
          break;
        }
      }
      
      // Determine complexity
      let complexityScore = 0;
      if (PROBLEM_COMPLEXITY.hasMath) complexityScore += 1;
      if (PROBLEM_COMPLEXITY.hasLogic) complexityScore += 1;
      if (PROBLEM_COMPLEXITY.multiStep) complexityScore += 1;
      
      // Apply more specific pattern checks
      
      // Advanced math indicators
      if (/(?:calculus|differential|integral|equation system|probability|statistics|algebra|geometry)/i.test(message)) {
        complexityScore += 1;
      }
      
      // Long problems are often complex
      if (message.length > 500) {
        complexityScore += 1;
      }
      
      // Multiple constraints or variables
      if (message.match(/(?:constraint|variable|unknown|factor|parameter|condition)/gi)?.length > 2) {
        complexityScore += 1;
      }
      
      // Update complexity level
      if (complexityScore >= 3) {
        PROBLEM_COMPLEXITY.complexity = "complex";
        // Estimate number of steps needed based on problem length and complexity
        PROBLEM_COMPLEXITY.estimatedSteps = Math.max(
          5, 
          Math.min(20, Math.ceil(PROBLEM_COMPLEXITY.wordCount / 15))
        );
      } else if (complexityScore >= 1) {
        PROBLEM_COMPLEXITY.complexity = "normal";
        PROBLEM_COMPLEXITY.estimatedSteps = Math.max(
          3, 
          Math.min(10, Math.ceil(PROBLEM_COMPLEXITY.wordCount / 20))
        );
      } else {
        PROBLEM_COMPLEXITY.complexity = "simple";
        PROBLEM_COMPLEXITY.estimatedSteps = Math.max(
          2, 
          Math.min(5, Math.ceil(PROBLEM_COMPLEXITY.wordCount / 25))
        );
      }
      
      // Adjust the estimated steps based on problem characteristics
      if (PROBLEM_COMPLEXITY.hasMath && PROBLEM_COMPLEXITY.multiStep) {
        PROBLEM_COMPLEXITY.estimatedSteps += 2; // Add more steps for multi-step math problems
      }
      
      if (PROBLEM_COMPLEXITY.hasLogic) {
        PROBLEM_COMPLEXITY.estimatedSteps += 1; // Add more steps for logical reasoning
      }
      
      // If the problem has math expressions, ensure minimum steps
      if (PROBLEM_COMPLEXITY.hasMath) {
        PROBLEM_COMPLEXITY.estimatedSteps = Math.max(PROBLEM_COMPLEXITY.estimatedSteps, 4);
      }
      
      console.log(`Problem analysis: ${JSON.stringify(PROBLEM_COMPLEXITY)}`);
      
      return PROBLEM_COMPLEXITY;
    }

    /***********************
     * Parse User Message for Word Count Requirements
     ***********************/
    function formatFinalAnswer(answer) {
      if (!answer) return '';
  
    // Clean up the answer text
      let formattedAnswer = answer.trim();
  
    // Remove any leading markers if they exist
      formattedAnswer = formattedAnswer.replace(/^(Answer:|Final answer:|The answer is:|Therefore,|Thus,|Hence,)/i, '').trim();
  
    // Apply markup for better readability if needed
      return formattedAnswer;
    }  
    function parseWordCountRequest(message) {
      // Common patterns for word count requests
      const patterns = [
        /(\d+)\s*words?/i, // Matches: "50 words", "100 word", etc.
        /in\s*(\d+)\s*words/i, // Matches: "in 50 words", "in 100 words"
        /limit\s*(\d+)\s*words/i, // Matches: "limit 50 words", "limit to 100 words"
        /answer\s*in\s*(\d+)\s*words/i, // Matches: "answer in 50 words"
        /respond\s*in\s*(\d+)\s*words/i, // Matches: "respond in 50 words"
        /keep\s*it\s*to\s*(\d+)\s*words/i, // Matches: "keep it to 50 words"
        /no\s*more\s*than\s*(\d+)\s*words/i, // Matches: "no more than 50 words"
        /under\s*(\d+)\s*words/i, // Matches: "under 50 words"
        /maximum\s*of\s*(\d+)\s*words/i, // Matches: "maximum of 50 words"
        /max\s*(\d+)\s*words/i // Matches: "max 50 words"
      ];

      // Check each pattern
      for (const pattern of patterns) {
        const match = message.match(pattern);
        if (match && match[1]) {
          const wordCount = parseInt(match[1]);
          if (!isNaN(wordCount) && wordCount > 0) {
            return wordCount;
          }
        }
      }

      // No word count requirement found
      return null;
    }

    // Helper function to normalize answers for better matching
    function normalizeAnswer(answer) {
      // Remove common prefixes
      let normalized = answer.replace(/^(the answer is|therefore|thus|so|hence|the result is|we get|we find that|the final answer is|the value is|the solution is):\s*/i, "");
      
      // Remove units for better matching (but preserve them for display)
      const unitRegex = /\b(dollars|inches|feet|meters|pounds|kg|miles|km|years|days|hours|minutes|seconds|percent|degrees|watts|volts|amps|\$|%|¬∞C|¬∞F)\b/gi;
      
      // Store the units to preserve the full answer
      const units = answer.match(unitRegex) || [];
      
      // Temporarily remove units for comparison
      normalized = normalized.replace(unitRegex, "");
      
      // Remove common formatting and punctuation, keeping only core answer
      normalized = normalized.replace(/[.,;:!\s]+/g, " ").trim();
      
      // Convert to lowercase for case-insensitive comparison
      normalized = normalized.toLowerCase();
      
      return normalized;
    }

    /***********************
     * Download as TXT
     ***********************/
    function downloadCurrentThreadAsTxt() {
      const thread = threads.find(t => t.id === currentThreadId);
      if (!thread) return;

      let content = `Model: ${MODEL_NAME_DISPLAY} (${REASONING_METHOD.toUpperCase()}`;
      if (REASONING_METHOD === "cod") {
        content += `-${COD_WORD_LIMIT}`;
      }
      content += `)\n\n`;

      thread.messages.forEach(msg => {
        const prefix = msg.sender.toUpperCase();
        
        // Add word count info for bot messages
        let headerInfo = prefix;
        if (msg.sender === "bot" && !msg.isPlaceholder && msg.wordCount !== undefined) {
          let countInfo = `[${msg.wordCount} words - ${msg.reasoningMethod || REASONING_METHOD.toUpperCase()}]`;
          if (msg.thinkingWordCount !== undefined && msg.answerWordCount !== undefined) {
            countInfo += ` (thinking: ${msg.thinkingWordCount}, answer: ${msg.answerWordCount})`;
          }
          headerInfo += ` ${countInfo}`;
        }
        
        content += `${headerInfo}:\n`;
        
        // Special handling for messages with thinking/answer components
        if (msg.sender === "bot" && msg.thinking && msg.answer) {
          content += `THINKING STEPS:\n${msg.thinking}\n\nFINAL ANSWER:\n${msg.answer}\n`;
        } else {
          const parsed = parseContentForExport(msg.content);
          parsed.forEach(item => {
            if (item.type === 'text') {
              content += item.content + '\n';
            } else if (item.type === 'code') {
              const lang = item.language ? ` (${item.language})` : '';
              content += `----- CODE BLOCK START${lang} -----\n`;
              item.content.forEach(line => {
                content += `  ${line}\n`;
              });
              content += `----- CODE BLOCK END -----\n`;
            }
          });
        }
        content += '\n';
      });

      const blob = new Blob([content], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `${thread.name}.txt`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showNotification("TXT file downloaded");
    }

    /***********************
     * Download as PDF
     ***********************/
     async function downloadCurrentThreadAsPdf() {
  const thread = threads.find(t => t.id === currentThreadId);
  if (!thread) return;

  try {
    // Make sure jsPDF is available
    if (!window.jspdf || !window.jspdf.jsPDF) {
      showNotification("PDF library not loaded. Please try again.", 3000);
      console.error("jsPDF not found:", window.jspdf);
      return;
    }

    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({
      unit: "pt",
      format: "letter"
    });

    function setPageBackground(doc) {
      doc.setFillColor(30, 30, 30);
      doc.rect(0, 0, doc.internal.pageSize.width, doc.internal.pageSize.height, 'F');
    }

    setPageBackground(doc);
    doc.setTextColor(224, 224, 224);

    let yPos = 40;
    const lineHeight = 14;
    const leftMargin = 40;
    const pageHeight = doc.internal.pageSize.height - 50; // Margin at bottom

    // Check if we need a new page
    function checkNewPage() {
      if (yPos > pageHeight) {
        doc.addPage();
        setPageBackground(doc);
        yPos = 40;
        return true;
      }
      return false;
    }

    doc.setFont("helvetica", "bold");
    doc.setFontSize(12);
    let modelInfo = `Model: ${MODEL_NAME_DISPLAY} (${REASONING_METHOD.toUpperCase()}`;
    if (REASONING_METHOD === "cod") {
      modelInfo += `-${COD_WORD_LIMIT}`;
    }
    modelInfo += `)`;
    doc.text(modelInfo, leftMargin, yPos);
    yPos += 20;
    doc.text(thread.name, leftMargin, yPos);
    yPos += 20;

    thread.messages.forEach(msg => {
      checkNewPage();
      
      doc.setFont("helvetica", "bold");
      doc.setFontSize(10);
      
      // Add word count info for bot messages
      let sender = msg.sender.toUpperCase() + ":";
      if (msg.sender === "bot" && !msg.isPlaceholder && msg.wordCount !== undefined) {
        let countInfo = `[${msg.wordCount} words - ${msg.reasoningMethod || REASONING_METHOD.toUpperCase()}]`;
        if (msg.thinkingWordCount !== undefined && msg.answerWordCount !== undefined) {
          countInfo += ` (thinking: ${msg.thinkingWordCount}, answer: ${msg.answerWordCount})`;
        }
        sender += ` ${countInfo}`;
      }
      
      doc.text(sender, leftMargin, yPos);
      yPos += lineHeight;

      // Special handling for messages with thinking/answer components
      if (msg.sender === "bot" && !msg.isPlaceholder && (msg.thinking || msg.answer)) {
        // If we have thinking steps, render them
        if (msg.thinking) {
          checkNewPage();
          doc.setFont("helvetica", "italic");
          doc.setFontSize(9);
          doc.setTextColor(180, 180, 180);
          doc.text("THINKING STEPS:", leftMargin, yPos);
          yPos += lineHeight;
          
          doc.setFont("courier", "normal");
          const thinkingLines = msg.thinking.split(/\r?\n/);
          thinkingLines.forEach(line => {
            checkNewPage();
            const wrapped = doc.splitTextToSize(line, 520);
            wrapped.forEach(wLine => {
              doc.text(wLine, leftMargin + 10, yPos);
              yPos += lineHeight;
              checkNewPage();
            });
          });
          
          yPos += lineHeight/2;
          checkNewPage();
        }
        
        // If we have an answer, render it
        if (msg.answer) {
          checkNewPage();
          doc.setFont("helvetica", "bold");
          doc.setFontSize(9);
          doc.setTextColor(144, 205, 244);
          doc.text("FINAL ANSWER:", leftMargin, yPos);
          yPos += lineHeight;
          
          doc.setFont("helvetica", "normal");
          doc.setTextColor(224, 224, 224);
          doc.setFontSize(10);
          const answerLines = msg.answer.split(/\r?\n/);
          answerLines.forEach(line => {
            checkNewPage();
            const wrapped = doc.splitTextToSize(line, 520);
            wrapped.forEach(wLine => {
              doc.text(wLine, leftMargin + 10, yPos);
              yPos += lineHeight;
              checkNewPage();
            });
          });
        }
      } else {
        // Standard rendering for other messages
        const parsed = parseContentForExport(msg.content);
        parsed.forEach(item => {
          if (item.type === 'text') {
            doc.setFont("helvetica", "normal");
            const line = item.content;
            checkNewPage();
            const wrapped = doc.splitTextToSize(line, 520);
            wrapped.forEach(wLine => {
              doc.text(wLine, leftMargin, yPos);
              yPos += lineHeight;
              checkNewPage();
            });
          } else if (item.type === 'code') {
            checkNewPage();
            doc.setFont("helvetica", "bold");
            const lang = item.language ? ` (${item.language})` : '';
            doc.text(`Code Block${lang}:`, leftMargin, yPos);
            yPos += lineHeight;

            doc.setFont("courier", "normal");
            item.content.forEach(codeLine => {
              checkNewPage();
              const wrapped = doc.splitTextToSize(codeLine, 520);
              wrapped.forEach(wLine => {
                doc.text(wLine, leftMargin + 20, yPos);
                yPos += lineHeight;
                checkNewPage();
              });
            });
          }
        });
      }
      yPos += lineHeight;
    });

    doc.save(`${thread.name}.pdf`);
    showNotification("PDF file downloaded");
  } catch (error) {
    console.error("PDF generation error:", error);
    showNotification("Error generating PDF: " + error.message);
  }
}

    /***********************
     * Process Bot Messages - IMPROVED VERSION FOR COD
     ***********************/
    function processBotMessage(content, reasoningMethod) {
      // For Chain of Draft (CoD) mode, extract thinking steps and final answer
      if (reasoningMethod === "cod") {
        const separatorIndex = content.indexOf("####");
        
        if (separatorIndex !== -1) {
          // Extract thinking steps and final answer
          let thinking = content.substring(0, separatorIndex).trim();
          let answer = content.substring(separatorIndex + 4).trim();
          
          return {
            content: content,
            thinking: thinking,
            answer: answer,
            thinkingWordCount: countWords(thinking),
            answerWordCount: countWords(answer)
          };
        } else {
          // Try to identify thinking steps and final answer based on structure
          // Look for phrases that might indicate a conclusion
          const conclusionPhrases = [
            "Therefore", "Thus", "Hence", "So", "Result", "Answer", "Finally", 
            "In conclusion", "The answer is", "This gives us"
          ];
          
          // Split by periods to identify steps
          const parts = content.split('.');
          if (parts.length > 1) {
            // Use the last part as the answer and everything else as thinking
            const lastPart = parts.pop().trim();
            const thinking = parts.join('.').trim();
            
            return {
              content: content,
              thinking: thinking,
              answer: lastPart,
              thinkingWordCount: countWords(thinking),
              answerWordCount: countWords(lastPart)
            };
          }
        }
      }
      
      // For Chain of Thought (CoT) mode, try to identify a logical final answer section
      if (reasoningMethod === "cot") {
        // Look for potential conclusion markers
        const conclusionMarkers = [
          "Therefore", "In conclusion", "So,", "Thus,", "Hence,", 
          "The answer is", "To conclude", "Finally,", "In summary",
          "As a result", "Consequently", "The final answer"
        ];
        
        // Add a marker for just "Answer:" or "Final answer:" on its own line
        const answerMarkers = [
          /\n(Answer:|Final answer:)/i,
          /^(Answer:|Final answer:)/i,
          /\n(The answer is:|My answer is:|Final answer is:)/i
        ];
        
        // Try each answer marker pattern
        for (const pattern of answerMarkers) {
          const answerMatch = content.match(pattern);
          if (answerMatch && answerMatch.index !== undefined) {
            // Found a marker
            const thinking = content.substring(0, answerMatch.index).trim();
            const answer = content.substring(answerMatch.index + answerMatch[0].length).trim();
            
            return {
              content: content,
              thinking: thinking,
              answer: answer,
              thinkingWordCount: countWords(thinking),
              answerWordCount: countWords(answer)
            };
          }
        }
        
        // If no explicit answer marker, look for conclusion indicator words
        let lastMarkerIndex = -1;
        let bestMarker = "";
        
        for (const marker of conclusionMarkers) {
          // Check for the marker near the end of the text (last 40%)
          const startSearchPos = content.length * 0.6;
          const markerIndex = content.indexOf(marker, startSearchPos);
          
          if (markerIndex > lastMarkerIndex && markerIndex !== -1) {
            lastMarkerIndex = markerIndex;
            bestMarker = marker;
          }
        }
        
        // If we found a conclusion marker in a reasonable position
        if (lastMarkerIndex > content.length * 0.6) {
          const thinking = content.substring(0, lastMarkerIndex).trim();
          const answer = content.substring(lastMarkerIndex).trim();
          
          return {
            content: content,
            thinking: thinking,
            answer: answer,
            thinkingWordCount: countWords(thinking),
            answerWordCount: countWords(answer)
          };
        }
        
        // Last resort: if text has multiple paragraphs, try to use the last paragraph as answer
        const paragraphs = content.split(/\n\s*\n/);
        if (paragraphs.length > 1) {
          const lastParagraph = paragraphs[paragraphs.length - 1].trim();
          // Only use last paragraph as answer if it's relatively short compared to whole text
          if (lastParagraph.length < content.length * 0.3) {
            const thinking = content.substring(0, content.lastIndexOf(lastParagraph)).trim();
            return {
              content: content,
              thinking: thinking,
              answer: lastParagraph,
              thinkingWordCount: countWords(thinking),
              answerWordCount: countWords(lastParagraph)
            };
          }
        }
      }
      
      // For standard reasoning
      if (reasoningMethod === "standard") {
        return {
          content: content,
          thinking: null, 
          answer: content,
          thinkingWordCount: 0,
          answerWordCount: countWords(content)
        };
      }
      
      // Default: if unable to separate, return entire content
      return {
        content: content,
        thinking: reasoningMethod === "cot" || reasoningMethod === "cod" ? content : null,
        answer: reasoningMethod === "standard" ? content : null,
        thinkingWordCount: reasoningMethod === "cot" || reasoningMethod === "cod" ? countWords(content) : 0,
        answerWordCount: reasoningMethod === "standard" ? countWords(content) : 0
      };
    }

    /***********************
     * Format Thinking Steps - IMPROVED FOR COD
     ***********************/
    function formatThinkingSteps(thinking, reasoningMethod) {
      if (!thinking) return '';
      
      // Remove any "###" prefixes
      let cleanedThinking = thinking.replace(/^#{1,3}\s*/gm, '');
      
      if (reasoningMethod === "cod") {
        // Split by periods to separate steps for CoD
        let steps = cleanedThinking.split(/\.\s*/).filter(step => step.trim().length > 0);
        
        // Create formatted steps including reflection handling
        return steps.map((step, index) => {
          // Check if this is a reflection step
          const isReflection = step.toLowerCase().includes('reflection:') || 
                             step.toLowerCase().includes('checking work:') ||
                             step.toLowerCase().includes('verifying:');
          
          const stepClass = isReflection ? 'step cod-step reflection-step' : 'step cod-step';
          
          return `<div class="${stepClass}">
            <span class="step-number">${index + 1}</span>
            <span class="step-content">${step.trim()}${!step.endsWith('.') ? '.' : ''}</span>
          </div>`;
        }).join('');
      } else {
        // Original formatting for CoT
        let steps = cleanedThinking.split(/\.\s+/);
        return steps.filter(step => step.trim())
          .map(step => 
            `<div class="step">${step.trim()}${!step.endsWith('.') ? '.' : ''}</div>`
          ).join('');
      }
    }

    // New initialization function for self-reflection
    function initSelfReflection() {
      const toggle = document.getElementById('selfReflectionToggle');
      const infoPanel = document.getElementById('selfReflectionInfo');
      
      if (toggle) {
        toggle.checked = true;
        
        toggle.addEventListener('change', () => {
          if (infoPanel) {
            infoPanel.style.display = toggle.checked ? 'block' : 'none';
          }
          updateCurrentModelDisplay();
        });
      }
    }

    // Cleanup function
    function removeGlobalSelfConsistencyVars() {
      window.SELF_CONSISTENCY_ENABLED = undefined;
      window.SELF_CONSISTENCY_PATHS = undefined;
      window.initSelfConsistency = undefined;
      window.saveSelfConsistencySettings = undefined;
    }

    /***********************
     * Transform Message
     ***********************/
    function transformMessage(content) {
      // Remove "###" prefixes from lines
      let processedContent = content.replace(/^#{1,3}\s*/gm, '');
      
      // Replace code blocks with syntax highlighting
      const transformed = processedContent.replace(/```([\s\S]*?)```/g, (match, codeContent) => {
        let language = '';
        const lines = codeContent.split('\n');
        if (lines.length > 0 && !lines[0].includes(' ')) {
          language = lines[0].trim();
          lines.shift();
        }
        return `<pre><code class="${language}">${lines.join('\n')}</code></pre>`;
      });
      return transformed;
    }

    /***********************
     * Rendering Messages - IMPROVED VERSION
     ***********************/
    function renderCurrentThreadMessages() {
      const chatMessagesDiv = document.getElementById("chatMessages");
      chatMessagesDiv.innerHTML = "";
      const thread = threads.find(t => t.id === currentThreadId);
      if (thread) {
        thread.messages.forEach(msg => {
          const messageDiv = document.createElement("div");
          messageDiv.classList.add("message", msg.sender);
          if (msg.isPlaceholder) {
            messageDiv.classList.add("placeholder");
          }

          const timestampStr = msg.timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
          const timestampEl = document.createElement("small");
          timestampEl.textContent = timestampStr;
          timestampEl.style.color = "#aaa";
          timestampEl.style.display = "block";
          timestampEl.style.marginBottom = "0.5rem";
          messageDiv.appendChild(timestampEl);

          // Special handling for messages with thinking/answer components
          if (msg.sender === "bot" && !msg.isPlaceholder) {
            const messageContainer = document.createElement("div");
            messageContainer.className = "message-container";
            
            // If we have thinking steps (for CoT or CoD)
            if (msg.thinking) {
              const thinkingDiv = document.createElement("div");
              thinkingDiv.className = "thinking-steps";
              
              // Add different style class for CoD
              if (msg.reasoningMethod && msg.reasoningMethod.startsWith("COD")) {
                thinkingDiv.classList.add("cod-thinking");
              }
              
              const thinkingLabel = document.createElement("div");
              thinkingLabel.className = "thinking-label";
              thinkingLabel.textContent = msg.reasoningMethod && msg.reasoningMethod.startsWith("COD") ? 
                "Chain of Draft Steps" : "Thinking Steps";
              thinkingDiv.appendChild(thinkingLabel);
              
              // Format thinking steps using the improved formatted steps function
              const thinkingContent = document.createElement("div");
              thinkingContent.innerHTML = formatThinkingSteps(
                msg.thinking, 
                msg.reasoningMethod ? msg.reasoningMethod.toLowerCase() : REASONING_METHOD
              );
              thinkingDiv.appendChild(thinkingContent);
              
              messageContainer.appendChild(thinkingDiv);
            }
            
            // If we have an answer (for CoD, CoT or Standard)
            if (msg.answer) {
              const answerDiv = document.createElement("div");
              answerDiv.className = "final-answer";
              
              const answerLabel = document.createElement("div");
              answerLabel.className = "final-answer-label";
              answerLabel.textContent = "Final Answer";
              answerDiv.appendChild(answerLabel);
              
              const answerContent = document.createElement("div");
              // Use our new formatting function here
              answerContent.innerHTML = transformMessage(formatFinalAnswer(msg.answer));
              answerDiv.appendChild(answerContent);
              
              messageContainer.appendChild(answerDiv);
            }
            
            // If we have neither thinking nor answer (fall back to content)
            if (!msg.thinking && !msg.answer) {
              const contentEl = document.createElement("div");
              contentEl.innerHTML = transformMessage(msg.content);
              messageContainer.appendChild(contentEl);
            }
            
            messageDiv.appendChild(messageContainer);
          } else {
            // Standard rendering for user messages or placeholders
            const contentEl = document.createElement("div");
            contentEl.innerHTML = transformMessage(msg.content);
            messageDiv.appendChild(contentEl);
            
            // Add file attachments to user messages if present
            if (msg.sender === "user" && msg.files && msg.files.length > 0) {
              addFilesToMessage(messageDiv, msg.files);
            }
          }
          
          // Add word count badge for bot messages (except placeholders)
          if (msg.sender === "bot" && !msg.isPlaceholder && msg.wordCount !== undefined) {
            const wordCountBadge = document.createElement("div");
            wordCountBadge.className = "word-count-badge";
            
            // Calculate token savings if we have CoD
            let badgeText = `${msg.wordCount} words - ${msg.reasoningMethod || REASONING_METHOD.toUpperCase()}`;
            
            wordCountBadge.innerHTML = badgeText;
            
            // Add breakdown of thinking vs answer word counts
            if (msg.thinkingWordCount !== undefined && msg.answerWordCount !== undefined) {
              wordCountBadge.innerHTML += `
                <div class="word-count-breakdown">
                  <span class="count-item count-thinking">thinking: ${msg.thinkingWordCount}</span>
                  <span class="count-item count-answer">answer: ${msg.answerWordCount}</span>
                </div>
              `;
            }
            
            // If this is a CoD message, add token savings estimate
            if (msg.reasoningMethod && msg.reasoningMethod.startsWith("COD") && thread.messages.length > 1) {
              // Find a similar CoT message (if available) to compare token savings
              const cotMessages = thread.messages.filter(m => 
                m.sender === "bot" && 
                m.reasoningMethod && 
                m.reasoningMethod === "COT" && 
                !m.isPlaceholder
              );
              
              if (cotMessages.length > 0) {
                // Calculate average token savings compared to CoT
                const avgCotWords = cotMessages.reduce((sum, m) => sum + m.wordCount, 0) / cotMessages.length;
                const savings = Math.round(100 - ((msg.wordCount / avgCotWords) * 100));
                
                if (savings > 0) {
                  const savingsEl = document.createElement("div");
                  savingsEl.className = "token-savings";
                  savingsEl.textContent = `${savings}% fewer words than CoT`;
                  wordCountBadge.appendChild(savingsEl);
                }
              }
            }
            
            // Append the badge to the message div directly
            messageDiv.appendChild(wordCountBadge);
          }

          chatMessagesDiv.appendChild(messageDiv);
        });
        chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;
      }
      addCodeCopyButtons();
    }

    function addMessageToCurrentThread(content, sender, isPlaceholder = false, files = []) {
      const thread = threads.find(t => t.id === currentThreadId);
      if (thread) {
        // Process bot messages to separate thinking from answer
        let thinking = null;
        let answer = null;
        let thinkingWordCount = 0;
        let answerWordCount = 0;
        let totalWordCount = 0;
        
        if (sender === "bot" && !isPlaceholder) {
          const processed = processBotMessage(content, REASONING_METHOD);
          thinking = processed.thinking;
          answer = processed.answer;
          thinkingWordCount = processed.thinkingWordCount || 0;
          answerWordCount = processed.answerWordCount || 0;
          totalWordCount = thinkingWordCount + answerWordCount;
        }
        
        thread.messages.push({
          content,
          sender,
          isPlaceholder,
          timestamp: new Date(),
          wordCount: sender === "bot" && !isPlaceholder ? totalWordCount : undefined,
          reasoningMethod: sender === "bot" && !isPlaceholder ? 
            (REASONING_METHOD === "cod" ? `${REASONING_METHOD.toUpperCase()}-${COD_WORD_LIMIT}` : REASONING_METHOD.toUpperCase()) : 
            undefined,
          thinking,
          answer,
          thinkingWordCount: sender === "bot" && !isPlaceholder ? thinkingWordCount : undefined,
          answerWordCount: sender === "bot" && !isPlaceholder ? answerWordCount : undefined,
          // Add files to the message
          files: files && files.length > 0 ? files : undefined,
          // NEW: Add complexity info for debugging
          complexityInfo: sender === "user" ? PROBLEM_COMPLEXITY : undefined
        });
        renderCurrentThreadMessages();
      }
    }

    /***********************
     * Build Messages Array for Chat Completions
     ***********************/
    function buildMessagesForChat(wordCountRequest = null) {
      const thread = threads.find(t => t.id === currentThreadId);
      if (!thread) return [];
      
      const messages = [];
      
      let systemPrompt = "";
      
      // Use enhanced reasoning for complex problems if enabled
      let shouldUseEnhancedPrompt = false;
      let problemType = "";
      
      // Determine if this is a complex problem that needs enhanced reasoning
      if (ENHANCED_REASONING_ENABLED && REASONING_ENHANCEMENT === "adaptive") {
        if (PROBLEM_COMPLEXITY.complexity === "complex") {
          shouldUseEnhancedPrompt = true;
          problemType = "complex";
          console.log("Using enhanced prompts for complex problem detected");
        } 
        else if (PROBLEM_COMPLEXITY.hasMath && (PROBLEM_COMPLEXITY.multiStep || PROBLEM_COMPLEXITY.hasLogic)) {
          // Even if not fully "complex", if it has math AND either multi-step reasoning or logic,
          // it's still worth enhancing the prompt
          shouldUseEnhancedPrompt = true;
          problemType = "mathematical";
          console.log("Using enhanced prompts for mathematical problem detected");
        }
      }
      
      // If we have a reasoning method other than standard, add the system prompt
      if (REASONING_METHOD !== "standard") {
        // Determine which prompt to use based on complexity and settings
        if (shouldUseEnhancedPrompt) {
          if (REASONING_METHOD === "cot") {
            systemPrompt = ENHANCED_PROMPTS.cot;
          } else if (REASONING_METHOD === "cod") {
            // Use the appropriate CoD prompt based on word limit
            if (COD_WORD_LIMIT === 5) {
              systemPrompt = ENHANCED_PROMPTS.cod5;
            } else if (COD_WORD_LIMIT === 10) {
              systemPrompt = ENHANCED_PROMPTS.cod10;
            } else if (COD_WORD_LIMIT === 15) {
              systemPrompt = ENHANCED_PROMPTS.cod15;
            } else if (COD_WORD_LIMIT === 17) {
              systemPrompt = ENHANCED_PROMPTS.cod17;
            } else if (COD_WORD_LIMIT === 20) {
              systemPrompt = ENHANCED_PROMPTS.cod20;
            } else {
              // Fallback to standard prompt but update word limit
              systemPrompt = PROMPTS[REASONING_METHOD].replace(/\(\d+ words maximum per step\)/, `(${COD_WORD_LIMIT} words maximum per step)`);
            }
          }
        } else {
          // Use the selected reasoning method prompt
          systemPrompt = PROMPTS[REASONING_METHOD];
          
          // If it's COD, update the word limit
          if (REASONING_METHOD === "cod") {
            // First update the word limit
            systemPrompt = systemPrompt.replace(/\(\d+ words maximum per step\)/, `(${COD_WORD_LIMIT} words maximum per step)`);
            
            // If this is a problem that needs many steps, add instructions to use more steps
            if (PROBLEM_COMPLEXITY.estimatedSteps > 5) {
              // Insert guidance about using sufficient steps after the first paragraph
              const firstParagraphEnd = systemPrompt.indexOf("\n\n");
              if (firstParagraphEnd !== -1) {
                const beforeInsert = systemPrompt.substring(0, firstParagraphEnd);
                const afterInsert = systemPrompt.substring(firstParagraphEnd);
                
                const insertText = `\n\nIMPORTANT: This problem may require ${PROBLEM_COMPLEXITY.estimatedSteps}+ reasoning steps. Use as many steps as needed to fully solve the problem - it's better to break complex reasoning into more simple steps than to skip important details.`;
                
                systemPrompt = beforeInsert + insertText + afterInsert;
              }
            }
          }
        }
        
        // If word count limit was requested, modify the prompt to clarify it applies to final answer only
        if (wordCountRequest && wordCountRequest > 0) {
          if (REASONING_METHOD === "cod") {
            // For CoD, add the instruction right before the examples section
            const examplesIndex = systemPrompt.indexOf("Examples:");
            if (examplesIndex !== -1) {
              const beforeExamples = systemPrompt.substring(0, examplesIndex);
              const afterExamples = systemPrompt.substring(examplesIndex);
              
              systemPrompt = `${beforeExamples}\nIMPORTANT: Your final answer after the #### separator should be ${wordCountRequest} words maximum. The word limit applies ONLY to your final answer, not your thinking steps.\n\n${afterExamples}`;
            } else {
              systemPrompt += `\n\nIMPORTANT: Your final answer after the #### separator should be ${wordCountRequest} words maximum. The word limit applies ONLY to your final answer, not your thinking steps.`;
            }
          } else if (REASONING_METHOD === "cot") {
            // For CoT, add to the end of the prompt
            systemPrompt += `\n\nIMPORTANT: Your final answer should be ${wordCountRequest} words maximum. This word limit applies ONLY to your final answer, not your thinking process.`;
          }
        }
        
        let reasoningInfo = `${REASONING_METHOD.toUpperCase()}`;
        if (REASONING_METHOD === "cod") {
          reasoningInfo += `-${COD_WORD_LIMIT}`;
        }
        
        if (shouldUseEnhancedPrompt) {
          reasoningInfo += " (Enhanced for complex problem)";
        }
        
        console.log(`Using ${reasoningInfo} prompt`);
        
        if (wordCountRequest) {
          console.log(`Added instruction for ${wordCountRequest} word limit on final answer only`);
        }
        
        messages.push({
          role: "system",
          content: systemPrompt
        });
      } else {
        console.log("Using standard reasoning (no special prompt)");
        
        // If word count limit was requested, add a system message for it
        if (wordCountRequest && wordCountRequest > 0) {
          messages.push({
            role: "system",
            content: `Please limit your response to ${wordCountRequest} words maximum.`
          });
          console.log(`Added instruction for ${wordCountRequest} word limit`);
        }
      }
      
      // Add all user and assistant messages
      thread.messages
        .filter(msg => !msg.isPlaceholder)
        .forEach(msg => {
          messages.push({
            role: msg.sender === "user" ? "user" : "assistant",
            content: msg.content
          });
        });
      
      return messages;
    }

    /***********************
     * Message Sending
     ***********************/
    async function sendMessage(message) {
      // NEW: Analyze problem complexity if enhanced reasoning is enabled
      if (ENHANCED_REASONING_ENABLED && REASONING_ENHANCEMENT === "adaptive") {
        analyzeProblemComplexity(message);
      }
      
      // Check if there are files to be included
      const filesToSend = [...attachedFiles]; // Make a copy of the current files
      
      // Add message to thread with files
      addMessageToCurrentThread(message, "user", false, filesToSend);
      
      // Clear attached files after sending
      attachedFiles = [];
      const attachedFilesContainer = document.getElementById('attachedFiles');
      if (attachedFilesContainer) {
        attachedFilesContainer.innerHTML = '';
        attachedFilesContainer.style.display = 'none';
      }
      
      if (!MODEL_NAME) {
        const errorMsg = "Error: Please set the Model Name in the Settings.";
        addMessageToCurrentThread(errorMsg, "bot");
        console.error(errorMsg);
        return;
      }

      // Parse message for word count requirements
      const wordCountRequest = parseWordCountRequest(message);
      
      // If self-consistency is enabled and we're using CoD, use multiple paths
      if (SELF_CONSISTENCY_ENABLED && REASONING_METHOD === "cod") {
        addMessageToCurrentThread(`Generating ${SELF_CONSISTENCY_PATHS} reasoning paths to increase accuracy...`, "bot", true);
        const thread = threads.find(t => t.id === currentThreadId);
        const placeholderIndex = thread.messages.length - 1;
        
        // Build messages array with current settings and word count request
        const messagesForApi = buildMessagesForChat(wordCountRequest);
        
        // Base payload 
        const basePayload = {
          model: MODEL_NAME,
          max_tokens: MAX_TOKENS,
          top_p: TOP_P,
          temperature: TEMPERATURE + 0.2, // Increase temperature slightly for diversity
          messages: messagesForApi
        };
        
        try {
          // Generate multiple reasoning paths
          const responses = [];
          const answers = {};
          
          // Display progress in placeholder
          thread.messages[placeholderIndex] = {
            content: `Generating ${SELF_CONSISTENCY_PATHS} reasoning paths (0/${SELF_CONSISTENCY_PATHS} complete)...`,
            sender: "bot",
            isPlaceholder: true,
            timestamp: new Date()
          };
          renderCurrentThreadMessages();
          
          for (let i = 0; i < SELF_CONSISTENCY_PATHS; i++) {
            // Add timestamp to URL to prevent caching
            const timestamp = new Date().getTime();
            const cacheBuster = `?t=${timestamp}&path=${i}`;
            
            // Update payload with slightly different temperature for diversity
            const pathPayload = {
              ...basePayload,
              temperature: basePayload.temperature + (i * 0.05) // Gradually increase temperature
            };
            
            try {
              // Update progress
              thread.messages[placeholderIndex] = {
                content: `Generating ${SELF_CONSISTENCY_PATHS} reasoning paths (${i}/${SELF_CONSISTENCY_PATHS} complete)...`,
                sender: "bot",
                isPlaceholder: true,
                timestamp: new Date()
              };
              renderCurrentThreadMessages();
              
              // Set timeout for fetch to handle long-running requests
              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), 120000); // 2 minute timeout
              
              const response = await fetch(`${API_PROXY_URL}${cacheBuster}`, {
                method: "POST",
                headers: {
                  "Content-Type": "application/json"
                },
                body: JSON.stringify(pathPayload),
                signal: controller.signal
              });
              
              clearTimeout(timeoutId); // Clear the timeout
              
              if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
              }
              
              const data = await response.json();
              const botReply = data.choices &&
                             data.choices[0] &&
                             data.choices[0].message &&
                             data.choices[0].message.content;
                             
              if (botReply) {
                const trimmedReply = botReply.trim();
                responses.push(trimmedReply);
                
                // Process to extract answer
                const processed = processBotMessage(trimmedReply, REASONING_METHOD);
                const finalAnswer = processed.answer ? processed.answer.trim() : "";
                
                // Count this answer (simple voting)
                if (finalAnswer) {
                  // Normalize the answer a bit (remove common variants)
                  const normalizedAnswer = normalizeAnswer(finalAnswer);
                  answers[normalizedAnswer] = (answers[normalizedAnswer] || 0) + 1;
                }
              }
            } catch (error) {
              console.error(`Error in path ${i + 1}:`, error);
              // Continue with other paths even if one fails
            }
          }
          
          // Find the most common answer
          let mostCommonAnswer = "";
          let highestCount = 0;
          
          for (const [answer, count] of Object.entries(answers)) {
            if (count > highestCount) {
              mostCommonAnswer = answer;
              highestCount = count;
            }
          }
          
          // Calculate agreement percentage
          const agreementPercentage = (highestCount / SELF_CONSISTENCY_PATHS) * 100;
          
          // Find a response that contains the most common answer
          let bestResponse = "";
          for (const response of responses) {
            if (response.includes(mostCommonAnswer)) {
              bestResponse = response;
              break;
            }
          }
          
          // If no best response found (unlikely), use the first one
          if (!bestResponse && responses.length > 0) {
            bestResponse = responses[0];
          }
          
          if (bestResponse) {
            // Create response metadata
            let reasoningInfo = `${REASONING_METHOD.toUpperCase()}-${COD_WORD_LIMIT}`;
            reasoningInfo += `-SC-${SELF_CONSISTENCY_PATHS}`;
            
            // Add enhanced reasoning info if used
            if (ENHANCED_REASONING_ENABLED && 
                REASONING_ENHANCEMENT === "adaptive" && 
                PROBLEM_COMPLEXITY.complexity === "complex") {
              reasoningInfo += "-ENHANCED";
            }
            
            // Check if this is likely a code question
            const isCodeQuestion = bestResponse.includes("```");
            
            // Process the response to separate thinking and answer
            let processed;
            
            if (isCodeQuestion && REASONING_METHOD === "cod") {
              // Special handling for code questions with Chain of Draft
              const separatorIndex = bestResponse.indexOf("####");
              
              if (separatorIndex !== -1) {
                // We found the standard separator
                processed = {
                  content: bestResponse,
                  thinking: bestResponse.substring(0, separatorIndex).trim(),
                  answer: bestResponse.substring(separatorIndex + 4).trim(),
                };
              } else {
                // Look for the first code block as a separator
                const codeBlockMatch = bestResponse.match(/```[\s\S]*?```/g);
                
                if (codeBlockMatch && codeBlockMatch.length > 0) {
                  const firstCodeBlock = codeBlockMatch[0];
                  const codeIndex = bestResponse.indexOf(firstCodeBlock);
                  
                  if (codeIndex > 0) {
                    // Everything before the first code block is thinking
                    processed = {
                      content: bestResponse,
                      thinking: bestResponse.substring(0, codeIndex).trim(),
                      answer: bestResponse.substring(codeIndex).trim(),
                    };
                  } else {
                    // If code block is at the beginning, treat everything as answer
                    processed = {
                      content: bestResponse,
                      thinking: "",
                      answer: bestResponse,
                    };
                  }
                } else {
                  // Fall back to standard processing
                  processed = processBotMessage(bestResponse, REASONING_METHOD);
                }
              }
              
              // Calculate word counts
              if (processed.thinking) {
                processed.thinkingWordCount = countWords(processed.thinking);
              } else {
                processed.thinkingWordCount = 0;
              }
              
              if (processed.answer) {
                processed.answerWordCount = countWords(processed.answer);
              } else {
                processed.answerWordCount = 0;
              }
            } else {
              // Standard processing for non-code questions
              processed = processBotMessage(bestResponse, REASONING_METHOD);
            }
            
            // Build an explanation of the self-consistency results
            const selfConsistencyInfo = `

---
**Self-Consistency Summary:**
- Generated ${SELF_CONSISTENCY_PATHS} independent reasoning paths
- ${highestCount} paths agreed on this answer (${Math.round(agreementPercentage)}% agreement)`;
            
            // Append the self-consistency info to the answer
            if (processed.answer) {
              processed.answer += selfConsistencyInfo;
            } else {
              processed.answer = bestResponse + selfConsistencyInfo;
            }
            
            thread.messages[placeholderIndex] = {
              content: bestResponse + selfConsistencyInfo,
              sender: "bot",
              isPlaceholder: false,
              timestamp: new Date(),
              wordCount: (processed.thinkingWordCount || 0) + (processed.answerWordCount || 0),
              reasoningMethod: reasoningInfo,
              thinking: processed.thinking,
              answer: processed.answer,
              thinkingWordCount: processed.thinkingWordCount || 0,
              answerWordCount: processed.answerWordCount || 0,
              selfConsistencyResults: {
                paths: SELF_CONSISTENCY_PATHS,
                agreement: agreementPercentage,
                agreementCount: highestCount,
                allResponses: responses
              }
            };
          } else {
            thread.messages[placeholderIndex] = {
              content: "No valid responses received. Check model name and API key.",
              sender: "bot",
              isPlaceholder: false,
              timestamp: new Date(),
              wordCount: 0,
              reasoningMethod: REASONING_METHOD.toUpperCase(),
              thinking: null,
              answer: null,
              thinkingWordCount: 0,
              answerWordCount: 0
            };
          }
        } catch (error) {
          console.error("Error in self-consistency:", error);
          
          thread.messages[placeholderIndex] = {
            content: "Error generating multiple reasoning paths: " + error.message,
            sender: "bot",
            isPlaceholder: false,
            timestamp: new Date(),
            wordCount: 0,
            reasoningMethod: REASONING_METHOD.toUpperCase(),
            thinking: null,
            answer: null,
            thinkingWordCount: 0,
            answerWordCount: 0
          };
        }
        
        renderCurrentThreadMessages();
      } else {
        // Standard message sending (existing code)
        addMessageToCurrentThread("Bot is typing...", "bot", true);
        const thread = threads.find(t => t.id === currentThreadId);
        const placeholderIndex = thread.messages.length - 1;

        // Build messages array with current settings and word count request
        const messagesForApi = buildMessagesForChat(wordCountRequest);

        // Create payload
        const payload = {
          model: MODEL_NAME,
          max_tokens: MAX_TOKENS,
          top_p: TOP_P,
          temperature: TEMPERATURE,
          messages: messagesForApi
        };
        
        console.log(`Sending request with ${REASONING_METHOD} reasoning ${REASONING_METHOD === "cod" ? `(word limit: ${COD_WORD_LIMIT})` : ""}`);
        if (wordCountRequest) {
          console.log(`Final answer word limit requested: ${wordCountRequest} words`);
        }
        console.log(`Parameters: temp=${TEMPERATURE}, top_p=${TOP_P}`);

        try {
          // Add timestamp to URL to prevent caching
          const timestamp = new Date().getTime();
          const cacheBuster = `?t=${timestamp}`;
          
          // Set timeout for fetch to handle long-running requests
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 120000); // 2 minute timeout
          
          const response = await fetch(`${API_PROXY_URL}${cacheBuster}`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify(payload),
            signal: controller.signal
          });
          
          clearTimeout(timeoutId); // Clear the timeout
          
          if (!response.ok) {
            console.error("API response error:", response.status, response.statusText);
            throw new Error(`HTTP error! Status: ${response.status}`);
          }
          
          const data = await response.json();
          const botReply = data.choices &&
                           data.choices[0] &&
                           data.choices[0].message &&
                           data.choices[0].message.content;
          if (botReply) {
            const trimmedReply = botReply.trim();
            
            // Create response metadata
            let reasoningInfo = REASONING_METHOD.toUpperCase();
            if (REASONING_METHOD === "cod") {
              reasoningInfo += `-${COD_WORD_LIMIT}`;
            }
            
            // Add enhanced reasoning info if used
            if (ENHANCED_REASONING_ENABLED && 
                REASONING_ENHANCEMENT === "adaptive" && 
                PROBLEM_COMPLEXITY.complexity === "complex") {
              reasoningInfo += "-ENHANCED";
            }
            
            // Process bot message to separate thinking and answer parts
            const processed = processBotMessage(trimmedReply, REASONING_METHOD);
            
            thread.messages[placeholderIndex] = {
              content: trimmedReply,
              sender: "bot",
              isPlaceholder: false,
              timestamp: new Date(),
              wordCount: (processed.thinkingWordCount || 0) + (processed.answerWordCount || 0),
              reasoningMethod: reasoningInfo,
              thinking: processed.thinking,
              answer: processed.answer,
              thinkingWordCount: processed.thinkingWordCount || 0,
              answerWordCount: processed.answerWordCount || 0
            };
          } else {
            thread.messages[placeholderIndex] = {
              content: "No valid response received. Check model name and API key.",
              sender: "bot",
              isPlaceholder: false,
              timestamp: new Date(),
              wordCount: 0,
              reasoningMethod: REASONING_METHOD.toUpperCase(),
              thinking: null,
              answer: null,
              thinkingWordCount: 0,
              answerWordCount: 0
            };
          }
        } catch (error) {
          console.error("Error communicating with API:", error);
          
          // Provide more detailed error message
          let errorMessage = "Error communicating with API: " + error.message;
          
          // Add suggestions based on error type
          if (error.message.includes("Failed to fetch")) {
            errorMessage += "\n\nPossible solutions:\n1. Make sure your API key is set correctly in Netlify\n2. Check that your model name is valid\n3. Verify your internet connection";
          } else if (error.message.includes("aborted")) {
            errorMessage += "\n\nThe request timed out after 2 minutes. Try again or use a different model.";
          } else if (error.message.includes("502")) {
            errorMessage += "\n\nThe Qroq API server returned a 502 Bad Gateway error. This usually indicates a temporary server issue. Please try again in a few minutes.";
          }
          
          thread.messages[placeholderIndex] = {
            content: errorMessage,
            sender: "bot",
            isPlaceholder: false,
            timestamp: new Date(),
            wordCount: 0,
            reasoningMethod: REASONING_METHOD.toUpperCase(),
            thinking: null,
            answer: null,
            thinkingWordCount: 0,
            answerWordCount: 0
          };
        }
        renderCurrentThreadMessages();
      }
    }

    /***********************
     * Code Copy Feature
     ***********************/
    function addCodeCopyButtons() {
      const codeBlocks = document.querySelectorAll('pre code');
      codeBlocks.forEach(code => {
        if (code.parentElement.classList.contains('code-block-container')) {
          return;
        }
        const pre = code.parentElement;
        const container = document.createElement('div');
        container.className = 'code-block-container';
        pre.parentNode.insertBefore(container, pre);
        container.appendChild(pre);

        const copyBtn = document.createElement('button');
        copyBtn.className = 'copy-btn';
        copyBtn.textContent = 'Copy';
        copyBtn.addEventListener('click', () => {
          navigator.clipboard.writeText(code.innerText);
          copyBtn.textContent = 'Copied!';
          setTimeout(() => {
            copyBtn.textContent = 'Copy';
          }, 1500);
        });
        container.appendChild(copyBtn);
      });
    }

    /***********************
     * Notification System
     ***********************/
    function showNotification(message, duration = 3000) {
      const notification = document.getElementById("statusNotification");
      notification.textContent = message;
      notification.classList.add("show");
      
      setTimeout(() => {
        notification.classList.remove("show");
      }, duration);
    }

    /***********************
     * Feedback Form
     ***********************/
    function initFeedbackForm() {
      // Get references to elements
      const openBtn = document.getElementById('openFeedbackBtn');
      const modal = document.getElementById('feedbackModal');
      const closeBtn = document.getElementById('closeFeedbackModal');
      const modelInput = document.getElementById('feedbackModel');
      const reasoningInput = document.getElementById('feedbackReasoning');
      
      // Set up event listeners
      if (openBtn) {
        openBtn.addEventListener('click', () => {
          // Update hidden fields with current model info
          if (modelInput) modelInput.value = MODEL_NAME_DISPLAY || 'Not set';
          if (reasoningInput) {
            let reasoningMethod = REASONING_METHOD.toUpperCase();
            if (REASONING_METHOD === 'cod') {
              reasoningMethod += `-${COD_WORD_LIMIT}`;
            }
            reasoningInput.value = reasoningMethod;
          }
          
          // Show the modal
          if (modal) modal.style.display = 'block';
        });
      }
      
      if (closeBtn) {
        closeBtn.addEventListener('click', () => {
          if (modal) modal.style.display = 'none';
        });
      }
      
      // Close modal when clicking outside
      window.addEventListener('click', (event) => {
        if (event.target === modal) {
          modal.style.display = 'none';
        }
      });
      
      // Show success message after form submission
      const form = document.querySelector('form[name="feedback"]');
      if (form) {
        form.addEventListener('submit', () => {
          setTimeout(() => {
            showNotification('Thank you for your feedback!');
            if (modal) modal.style.display = 'none';
          }, 500);
        });
      }
    }

    /***********************
     * Settings Management
     ***********************/
    
    // Tab handling - FIXED VERSION
    function setupTabNavigation() {
      try {
        console.log("Setting up tab navigation");
        
        // Get all tab buttons and tab contents
        const tabButtons = document.querySelectorAll('.tab-btn');
        const tabContents = document.querySelectorAll('.tab-content');
        
        if (tabButtons.length === 0) {
          console.warn("No tab buttons found");
        }
        
        // Add click event listeners to tab buttons
        tabButtons.forEach(button => {
          button.addEventListener('click', () => {
            try {
              // Remove active class from all buttons and contents
              tabButtons.forEach(btn => btn.classList.remove('active'));
              tabContents.forEach(content => {
                content.classList.remove('active');
                content.style.display = 'none'; // Ensure all tabs are hidden
              });
              
              // Add active class to clicked button
              button.classList.add('active');
              
              // Show corresponding tab content
              const tabId = button.getAttribute('data-tab');
              const tabContent = document.getElementById(tabId);
              if (tabContent) {
                tabContent.classList.add('active');
                tabContent.style.display = 'block'; // Explicitly set display to block
              } else {
                console.warn(`Tab content with id "${tabId}" not found`);
              }
            } catch (err) {
              console.error("Error handling tab click:", err);
            }
          });
        });
      } catch (err) {
        console.error("Error in setupTabNavigation:", err);
      }
    }
    
    // Custom model handling
    function setupModelInput() {
      const modelSelect = document.getElementById('modelSelect');
      const setModelBtn = document.getElementById('setModelBtn');
      const modelInfoCard = document.getElementById('modelInfoCard');
      const selectedModelName = document.getElementById('selectedModelName');
      const modelTags = document.getElementById('modelTags');
      const modelDescription = document.getElementById('modelDescription');
      
      // Model information database for Qroq models
      const modelInfo = {
        "qwen-2.5-coder-32b": {
          name: "Qwen 2.5 Coder (32B)",
          tags: ["32B", "Coding", "Reasoning"],
          description: "Alibaba's Qwen 2.5 Coder model specialized for programming tasks with strong reasoning capabilities."
        },
        "llama-3.3-70b-versatile": {
          name: "Llama 3.3 (70B)",
          tags: ["70B", "Versatile", "Advanced"],
          description: "Meta's Llama 3.3 70B model offering strong performance across a wide range of tasks with advanced reasoning capabilities."
        },
        "mixtral-8x7b-32768": {
          name: "Mixtral 8x7B",
          tags: ["MoE", "General", "Balanced"],
          description: "Mixture of Experts model offering strong performance across diverse tasks."
        }
      };
      
      // Clear existing options except the default one
      while (modelSelect.options.length > 1) {
        modelSelect.remove(1);
      }
      
      // Add models from the modelInfo object
      for (const [id, info] of Object.entries(modelInfo)) {
        const option = document.createElement('option');
        option.value = id;
        option.textContent = info.name;
        modelSelect.appendChild(option);
      }
      
      // Initialize with current model if set
      if (MODEL_NAME && modelInfo[MODEL_NAME]) {
        modelSelect.value = MODEL_NAME;
        updateModelInfo(MODEL_NAME);
      }
      
      // Update model info card when selection changes
      modelSelect.addEventListener('change', () => {
        const selectedModel = modelSelect.value;
        updateModelInfo(selectedModel);
      });
      
      function updateModelInfo(modelId) {
        if (modelInfo[modelId]) {
          const info = modelInfo[modelId];
          
          // Update header
          selectedModelName.textContent = info.name;
          
          // Update tags
          modelTags.innerHTML = '';
          info.tags.forEach(tag => {
            const tagElement = document.createElement('span');
            tagElement.className = 'model-tag';
            tagElement.textContent = tag;
            modelTags.appendChild(tagElement);
          });
          
          // Update description
          modelDescription.textContent = info.description;
          
          // Show the card with animation
          modelInfoCard.style.display = 'block';
          modelInfoCard.style.opacity = '0';
          modelInfoCard.style.transform = 'translateY(10px)';
          
          // Animate in
          setTimeout(() => {
            modelInfoCard.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
            modelInfoCard.style.opacity = '1';
            modelInfoCard.style.transform = 'translateY(0)';
          }, 10);
        } else {
          // Hide or reset the card if no valid model
          selectedModelName.textContent = 'No model selected';
          modelTags.innerHTML = '';
          modelDescription.textContent = 'Select a model to see details';
        }
      }
      
      // Set model button
      setModelBtn.addEventListener('click', () => {
        const modelName = modelSelect.value;
        if (modelName) {
          MODEL_NAME = modelName;
          MODEL_NAME_DISPLAY = modelInfo[modelName] ? modelInfo[modelName].name : getModelDisplayName(modelName);
          updateCurrentModelDisplay();
          showNotification('Model set: ' + MODEL_NAME_DISPLAY);
        } else {
          showNotification('Please select a valid model');
        }
      });
    }
    
    // Improved Chain of Draft word limit options UI
    function updateCoDOptionsUI() {
      const codOptions = document.getElementById('codOptions');
      if (!codOptions) return;
      
      codOptions.innerHTML = `
        <div class="option-label">Word limit per step:</div>
        <div class="cod-word-limit-options">
          <div class="cod-word-limit-option ${COD_WORD_LIMIT === 5 ? 'selected' : ''}" data-value="5">
            <span class="cod-word-limit-value">5 words</span>
            <span class="cod-word-limit-desc">Original paper recommendation</span>
          </div>
          <div class="cod-word-limit-option ${COD_WORD_LIMIT === 10 ? 'selected' : ''}" data-value="10">
            <span class="cod-word-limit-value">10 words</span>
            <span class="cod-word-limit-desc">Balanced brevity and clarity</span>
          </div>
          <div class="cod-word-limit-option ${COD_WORD_LIMIT === 15 ? 'selected' : ''}" data-value="15">
            <span class="cod-word-limit-value">15 words</span>
            <span class="cod-word-limit-desc">More descriptive steps</span>
          </div>
          <div class="cod-word-limit-option ${COD_WORD_LIMIT === 17 ? 'selected' : ''}" data-value="17">
            <span class="cod-word-limit-value">17 words</span>
            <span class="cod-word-limit-desc">Better for complex reasoning</span>
          </div>
          <div class="cod-word-limit-option ${COD_WORD_LIMIT === 20 ? 'selected' : ''}" data-value="20">
            <span class="cod-word-limit-value">20 words</span>
            <span class="cod-word-limit-desc">Detailed steps for math & logic</span>
          </div>
        </div>
        
        <div class="cod-examples">
          <div class="cod-examples-header">Chain of Draft Example</div>
          <div class="cod-example-item">
            <div class="cod-example-question">Q: If a fabric store received 45 yards of cotton and used 2/9 of it, how many yards remain?</div>
            <div class="cod-example-answer">A: Total: 45 yards. Used: 2/9 √ó 45 = 10 yards. Remaining: 45 - 10 = 35 yards. #### 35 yards</div>
          </div>
        </div>
      `;
      
      // Add event listeners to the word limit options
      const wordLimitOptions = document.querySelectorAll('.cod-word-limit-option');
      wordLimitOptions.forEach(option => {
        option.addEventListener('click', () => {
          // Update selected state
          wordLimitOptions.forEach(opt => opt.classList.remove('selected'));
          option.classList.add('selected');
          
          // Update word limit value
          COD_WORD_LIMIT = parseInt(option.getAttribute('data-value'));
          
          // Update the prompt
          updateCoDPrompt();
          
          // Update display
          updateCurrentModelDisplay();
        });
      });
    }
    
    // Improved function to update the CoD prompt when word limit changes
    function updateCoDPrompt() {
      // Update the prompt to reflect new word limit
      const basePrompt = `Think step by step, but produce only minimal notes for each step (${COD_WORD_LIMIT} words maximum per step). Use mathematical notation where possible. Keep only essential information needed to solve the problem. Focus on key calculations and intermediate results without narrative explanation.
  
Separate your steps with periods. Write your final answer after the #### separator.`;
      
      // Keep the examples part of the prompt
      const examplesStart = PROMPTS.cod.indexOf('Examples:');
      if (examplesStart !== -1) {
        PROMPTS.cod = basePrompt + '\n\n' + PROMPTS.cod.substring(examplesStart);
      } else {
        PROMPTS.cod = basePrompt;
      }
      
      console.log(`Updated CoD prompt with word limit: ${COD_WORD_LIMIT}`);
    }
    
    // Setup Enhanced Reasoning options
    function setupEnhancedReasoningOptions() {
      const enhancedToggle = document.getElementById('enhancedReasoningToggle');
      const optionsContainer = document.getElementById('enhancedReasoningOptions');
      const adaptiveRadio = document.getElementById('adaptiveReasoning');
      const standardRadio = document.getElementById('standardReasoning');
      
      // Initialize state
      if (enhancedToggle) {
        enhancedToggle.checked = ENHANCED_REASONING_ENABLED;
        if (optionsContainer) {
          optionsContainer.style.display = ENHANCED_REASONING_ENABLED ? 'block' : 'none';
        }
      }
      
      if (adaptiveRadio && standardRadio) {
        if (REASONING_ENHANCEMENT === 'adaptive') {
          adaptiveRadio.checked = true;
        } else {
          standardRadio.checked = true;
        }
      }
      
      // Add event listeners
      if (enhancedToggle) {
        enhancedToggle.addEventListener('change', () => {
          ENHANCED_REASONING_ENABLED = enhancedToggle.checked;
          if (optionsContainer) {
            optionsContainer.style.display = ENHANCED_REASONING_ENABLED ? 'block' : 'none';
          }
          updateCurrentModelDisplay();
        });
      }
      
      if (adaptiveRadio) {
        adaptiveRadio.addEventListener('change', () => {
          if (adaptiveRadio.checked) {
            REASONING_ENHANCEMENT = 'adaptive';
            updateCurrentModelDisplay();
          }
        });
      }
      
      if (standardRadio) {
        standardRadio.addEventListener('change', () => {
          if (standardRadio.checked) {
            REASONING_ENHANCEMENT = 'standard';
            updateCurrentModelDisplay();
          }
        });
      }
    }
    
    // Setup COD options display
    function setupCODOptions() {
      const reasoningRadios = document.getElementsByName('reasoningMethod');
      const codOptions = document.getElementById('codOptions');
      
      // Initial state
      if (REASONING_METHOD === 'cod') {
        codOptions.style.display = 'block';
        updateCoDOptionsUI();
      } else {
        codOptions.style.display = 'none';
      }
      
      // Update when reasoning method changes
      reasoningRadios.forEach(radio => {
        radio.addEventListener('change', () => {
          if (radio.value === 'cod' && radio.checked) {
            codOptions.style.display = 'block';
            updateCoDOptionsUI();
          } else {
            codOptions.style.display = 'none';
          }
        });
      });
    }
    
    // Settings slider handling
    function setupSliders() {
      // Connect all sliders to their value displays
      document.querySelectorAll('input[type="range"]').forEach(slider => {
        const valueDisplay = document.getElementById(`${slider.id}Value`);
        if (valueDisplay) {
          slider.addEventListener('input', () => {
            valueDisplay.textContent = slider.value;
          });
        }
      });
    }
    
    function openSettingsModal() {
      try {
        console.log("Opening settings modal");
        
        // Initialize settings UI
        const modelNameInput = document.getElementById("modelName");
        if (modelNameInput) modelNameInput.value = MODEL_NAME;
        
        // Set reasoning method radio buttons
        const reasoningRadio = document.getElementById(`${REASONING_METHOD}Reasoning`);
        if (reasoningRadio) reasoningRadio.checked = true;
        
        // Set enhanced reasoning options
        const enhancedToggle = document.getElementById('enhancedReasoningToggle');
        if (enhancedToggle) enhancedToggle.checked = ENHANCED_REASONING_ENABLED;
        
        const enhancedOptionsContainer = document.getElementById('enhancedReasoningOptions');
        if (enhancedOptionsContainer) {
          enhancedOptionsContainer.style.display = ENHANCED_REASONING_ENABLED ? 'block' : 'none';
        }
        
        const adaptiveRadio = document.getElementById('adaptiveReasoning');
        const standardRadio = document.getElementById('standardReasoning');
        
        if (adaptiveRadio && standardRadio) {
          if (REASONING_ENHANCEMENT === 'adaptive') {
            adaptiveRadio.checked = true;
          } else {
            standardRadio.checked = true;
          }
        }
        
        // Set parameter sliders
        setSliderAndValue("temp", TEMPERATURE);
        setSliderAndValue("topP", TOP_P);
        setSliderAndValue("maxTokens", MAX_TOKENS);
        
        // Show modal
        const modal = document.getElementById("settingsModal");
        if (modal) modal.style.display = "block";
        
        // Reset tab state - ensure only the first tab is active
        const tabButtons = document.querySelectorAll('.tab-btn');
        const tabContents = document.querySelectorAll('.tab-content');
        
        // Hide all tabs first
        tabContents.forEach(content => {
          content.classList.remove('active');
          content.style.display = 'none';
        });
        
        // Deactivate all tab buttons
        tabButtons.forEach(btn => btn.classList.remove('active'));
        
        // Activate only the first tab
        if (tabButtons.length > 0) {
          tabButtons[0].classList.add('active');
          const firstTabId = tabButtons[0].getAttribute('data-tab');
          const firstTabContent = document.getElementById(firstTabId);
          if (firstTabContent) {
            firstTabContent.classList.add('active');
            firstTabContent.style.display = 'block';
          }
        }
        
        console.log("Settings modal opened successfully");
      } catch (err) {
        console.error("Error in openSettingsModal:", err);
      }
    }

    function setSliderAndValue(id, value) {
      const slider = document.getElementById(id);
      const valueDisplay = document.getElementById(`${id}Value`);
      
      if (slider) slider.value = value;
      if (valueDisplay) valueDisplay.textContent = value;
    }

    function closeSettingsModal() {
      document.getElementById("settingsModal").style.display = "none";
    }

    function saveSettings() {
      try {
        console.log("Saving settings...");
        
        // Save previous settings for comparison
        const prevMethod = REASONING_METHOD;
        const prevWordLimit = COD_WORD_LIMIT;
        const prevEnhanced = ENHANCED_REASONING_ENABLED;
        const prevEnhancementType = REASONING_ENHANCEMENT;
        const prevSelfConsistency = SELF_CONSISTENCY_ENABLED;
        const prevSelfConsistencyPaths = SELF_CONSISTENCY_PATHS;
        
        // Save model name
        const modelNameEl = document.getElementById("modelName");
        if (modelNameEl) {
          MODEL_NAME = modelNameEl.value.trim();
          MODEL_NAME_DISPLAY = getModelDisplayName(MODEL_NAME);
        }
        
        // Save reasoning method
        const reasoningRadios = document.getElementsByName("reasoningMethod");
        for (const radio of reasoningRadios) {
          if (radio.checked) {
            REASONING_METHOD = radio.value;
            break;
          }
        }
        
        // Save COD word limit if applicable
        if (REASONING_METHOD === "cod") {
          // Get the selected CoD word limit option
          const selectedOption = document.querySelector('.cod-word-limit-option.selected');
          if (selectedOption) {
            COD_WORD_LIMIT = parseInt(selectedOption.getAttribute('data-value'));
          }
        }
        
        // Save enhanced reasoning settings
        const enhancedToggle = document.getElementById('enhancedReasoningToggle');
        if (enhancedToggle) {
          ENHANCED_REASONING_ENABLED = enhancedToggle.checked;
        }
        
        const adaptiveRadio = document.getElementById('adaptiveReasoning');
        const standardRadio = document.getElementById('standardReasoning');
        
        if (adaptiveRadio && standardRadio) {
          if (adaptiveRadio.checked) {
            REASONING_ENHANCEMENT = 'adaptive';
          } else if (standardRadio.checked) {
            REASONING_ENHANCEMENT = 'standard';
          }
        }
        
        // Save self-consistency settings
        saveSelfConsistencySettings();
        
        // Save generation parameters safely
        const getNumericValue = (id, defaultVal, parseFunc) => {
          const el = document.getElementById(id);
          return el ? parseFunc(el.value) : defaultVal;
        };
        
        TEMPERATURE = getNumericValue("temp", 0.5, parseFloat);
        // Add this line - Qroq API can sometimes reject 0 as a temperature value
        if (TEMPERATURE === 0) TEMPERATURE = 0.01; // Ensure minimum value for Qroq API
        
        TOP_P = getNumericValue("topP", 0.9, parseFloat);
        MAX_TOKENS = getNumericValue("maxTokens", 1112, parseInt);
        
        // Update model display
        updateCurrentModelDisplay();
        
        // Save settings to localStorage
        try {
          localStorage.setItem("modelName", MODEL_NAME);
          localStorage.setItem("reasoningMethod", REASONING_METHOD);
          localStorage.setItem("codWordLimit", COD_WORD_LIMIT.toString());
          localStorage.setItem("enhancedReasoningEnabled", ENHANCED_REASONING_ENABLED.toString());
          localStorage.setItem("reasoningEnhancement", REASONING_ENHANCEMENT);
          localStorage.setItem("temperature", TEMPERATURE.toString());
          localStorage.setItem("topP", TOP_P.toString());
          localStorage.setItem("maxTokens", MAX_TOKENS.toString());
          
          // Save custom prompts
          localStorage.setItem("customPrompts", JSON.stringify(PROMPTS));
          localStorage.setItem("enhancedPrompts", JSON.stringify(ENHANCED_PROMPTS));
          console.log("Settings saved to localStorage");
        } catch (storageErr) {
          console.error("Error saving to localStorage:", storageErr);
        }
        
        closeSettingsModal();
        
        // Check if reasoning method or COD word limit changed and notify user
        if (prevMethod !== REASONING_METHOD || 
            (REASONING_METHOD === "cod" && prevMethod === "cod" && prevWordLimit !== COD_WORD_LIMIT) ||
            prevEnhanced !== ENHANCED_REASONING_ENABLED ||
            prevEnhancementType !== REASONING_ENHANCEMENT) {
          showNotification("Settings saved - reasoning method changed. Next message will use new settings.");
        } else {
          showNotification("Settings saved");
        }
      } catch (err) {
        console.error("Error in saveSettings:", err);
        showNotification("Error saving settings");
      }
    }

    // ADD this function to ensure tab content displays correctly
    function fixTabContentDisplay() {
      // This function will be replaced with a better implementation in setupTabNavigation
      console.log("Using improved tab navigation instead of fixTabContentDisplay");
    }

    /***********************
     * Event Listeners
     ***********************/
    function initEventListeners() {
      try {
        console.log("Initializing event listeners");
        
        // Helper function to safely add event listeners
        const addListener = (id, event, handler) => {
          const element = document.getElementById(id);
          if (element) {
            element.addEventListener(event, handler);
          } else {
            console.warn(`Element with id "${id}" not found for event listener`);
          }
        };
        
        // Settings buttons
        addListener("openSettings", "click", openSettingsModal);
        addListener("closeSettings", "click", closeSettingsModal);
        addListener("closeModalX", "click", closeSettingsModal);
        addListener("saveSettings", "click", saveSettings);
        
        // Thread management
        addListener("newThreadBtn", "click", createNewThread);
        addListener("deleteThreadBtn", "click", deleteCurrentThread);
        addListener("downloadTxtBtn", "click", downloadCurrentThreadAsTxt);
        addListener("downloadPdfBtn", "click", downloadCurrentThreadAsPdf);
        
        // Message sending
        addListener("sendBtn", "click", () => {
          const userInput = document.getElementById("userInput");
          if (userInput) {
            const message = userInput.value.trim();
            if (message || attachedFiles.length > 0) {
              sendMessage(message);
              userInput.value = "";
            }
          }
        });
        
        const userInput = document.getElementById("userInput");
        if (userInput) {
          userInput.addEventListener("keydown", (event) => {
            if (event.key === "Enter" && !event.shiftKey) {
              event.preventDefault();
              const sendBtn = document.getElementById("sendBtn");
              if (sendBtn) sendBtn.click();
            }
          });
        }
        
        // Initialize file upload handling
        handleFileInput();
        
        // Close modal when clicking outside
        window.addEventListener("click", (event) => {
          const modal = document.getElementById("settingsModal");
          if (modal && event.target === modal) {
            closeSettingsModal();
          }
        });
        
        // Set up settings UI functionality
        setTimeout(() => {
          try {
            setupTabNavigation();
            setupModelInput();
            setupCODOptions();
            setupEnhancedReasoningOptions();
            setupSliders();
            initSelfConsistency();
            console.log("UI functionality setup complete");
          } catch (err) {
            console.error("Error setting up UI functionality:", err);
          }
        }, 100);
      } catch (err) {
        console.error("Error initializing event listeners:", err);
      }
    }

    /***********************
     * Initialization
     ***********************/
    function loadPersistedSettings() {
      try {
        MODEL_NAME = localStorage.getItem("modelName") || "";
        MODEL_NAME_DISPLAY = getModelDisplayName(MODEL_NAME);
        
        REASONING_METHOD = localStorage.getItem("reasoningMethod") || "cod";
        
        const codWordLimit = localStorage.getItem("codWordLimit");
        if (codWordLimit) COD_WORD_LIMIT = parseInt(codWordLimit);
        
        // Load enhanced reasoning settings
        const enhancedEnabled = localStorage.getItem("enhancedReasoningEnabled");
        if (enhancedEnabled !== null) {
          ENHANCED_REASONING_ENABLED = enhancedEnabled === "true";
        }
        
        const enhancementType = localStorage.getItem("reasoningEnhancement");
        if (enhancementType) {
          REASONING_ENHANCEMENT = enhancementType;
        }
        
        // Load custom prompts if available
        const storedPrompts = localStorage.getItem("customPrompts");
        if (storedPrompts) {
          const parsedPrompts = JSON.parse(storedPrompts);
          // Merge with default prompts to ensure all properties exist
          PROMPTS = { ...PROMPTS, ...parsedPrompts };
        }
        
        // Load enhanced prompts if available
        const storedEnhancedPrompts = localStorage.getItem("enhancedPrompts");
        if (storedEnhancedPrompts) {
          const parsedEnhancedPrompts = JSON.parse(storedEnhancedPrompts);
          // Merge with default prompts to ensure all properties exist
          ENHANCED_PROMPTS = { ...ENHANCED_PROMPTS, ...parsedEnhancedPrompts };
        }
        
        const temp = localStorage.getItem("temperature");
        if (temp) TEMPERATURE = parseFloat(temp);
        
        const topP = localStorage.getItem("topP");
        if (topP) TOP_P = parseFloat(topP);
        
        const maxTokens = localStorage.getItem("maxTokens");
        if (maxTokens) MAX_TOKENS = parseInt(maxTokens);
        
        // Load self-consistency settings
        const selfConsistencyEnabled = localStorage.getItem("selfConsistencyEnabled");
        if (selfConsistencyEnabled !== null) {
          SELF_CONSISTENCY_ENABLED = selfConsistencyEnabled === "true";
        }
        
        const selfConsistencyPaths = localStorage.getItem("selfConsistencyPaths");
        if (selfConsistencyPaths) {
          SELF_CONSISTENCY_PATHS = parseInt(selfConsistencyPaths);
        }
      } catch (err) {
        console.error("Error loading settings:", err);
      }
    }

    function init() {
      console.log("Initializing app...");
      
      try {
        removeGlobalSelfConsistencyVars();
        loadPersistedSettings();
        console.log("Settings loaded");
        
        // Update CoD prompt with the correct word limit
        updateCoDPrompt();
        console.log("CoD prompt updated");
        
        createNewThread();
        console.log("New thread created");
        
        initEventListeners();
        console.log("Event listeners initialized");
        
        updateCurrentModelDisplay();
        console.log("Model display updated");
        
        // Initialize feedback form
        initFeedbackForm();
        console.log("Feedback form initialized");
        
       // Add clear thread button event listener (using existing button in HTML)
       const clearThreadBtn = document.getElementById("clearThreadBtn");
      if (clearThreadBtn) {
      clearThreadBtn.addEventListener("click", () => {
      if (confirm("Clear all messages in this thread?")) {
        const thread = threads.find(t => t.id === currentThreadId);
        if (thread) {
        thread.messages = [];
        renderCurrentThreadMessages();
        showNotification("Thread cleared");
      }
    }
  });
  console.log("Clear thread button initialized");
} else {
  console.warn("Clear thread button not found in DOM");
}
        
        // Add clear thread button to the sidebar
        const sidebar = document.querySelector(".sidebar");
        if (sidebar) {
          sidebar.appendChild(createClearThreadButton());
        }
        
        // If we don't have a model name, open settings modal
        if (!MODEL_NAME) {
          console.log("No model name found, opening settings");
          setTimeout(() => {
            try {
              openSettingsModal();
              console.log("Settings modal opened");
            } catch (err) {
              console.error("Error opening settings modal:", err);
            }
          }, 1000);
        }
        
        // No longer need this function as we've improved the tab navigation
        // setTimeout(() => {
        //   fixTabContentDisplay();
        //   console.log("Fixed tab content display");
        // }, 200);
      } catch (err) {
        console.error("Initialization error:", err);
      }
    }

    // Initialize the application
    document.addEventListener("DOMContentLoaded", init);
    
    // Backup initialization - in case the DOMContentLoaded event already fired
    if (document.readyState === "complete" || document.readyState === "interactive") {
      setTimeout(init, 1);
    }

    /***********************
     * File Upload Management
     ***********************/
    let attachedFiles = [];
    
    function handleFileInput() {
      const fileInput = document.getElementById('fileInput');
      const attachedFilesContainer = document.getElementById('attachedFiles');
      
      fileInput.addEventListener('change', (event) => {
        const files = event.target.files;
        
        if (files.length > 0) {
          // Show the container if it was hidden
          attachedFilesContainer.style.display = 'flex';
          
          // Process each file
          for (let i = 0; i < files.length; i++) {
            const file = files[i];
            
            // Check if the file is already in the list
            const isDuplicate = attachedFiles.some(f => f.name === file.name && f.size === file.size);
            if (isDuplicate) continue;
            
            // Add file to attachedFiles array
            attachedFiles.push(file);
            
            // Create file preview
            createFilePreview(file);
          }
          
          // Reset the file input
          fileInput.value = '';
        }
      });
    }
    
    function createFilePreview(file) {
      const attachedFilesContainer = document.getElementById('attachedFiles');
      const filePreview = document.createElement('div');
      filePreview.className = 'file-preview';
      
      // Create preview content based on file type
      if (file.type.startsWith('image/')) {
        // Create image preview for image files
        const reader = new FileReader();
        reader.onload = (e) => {
          const img = document.createElement('img');
          img.className = 'file-preview-image';
          img.src = e.target.result;
          filePreview.appendChild(img);
          
          // Add file name
          const fileName = document.createElement('div');
          fileName.className = 'file-preview-name';
          fileName.textContent = file.name;
          filePreview.appendChild(fileName);
        };
        reader.readAsDataURL(file);
      } else {
        // Create icon preview for non-image files
        const icon = document.createElement('div');
        icon.className = 'file-preview-icon';
        icon.textContent = getFileIcon(file.type);
        filePreview.appendChild(icon);
        
        // Add file name
        const fileName = document.createElement('div');
        fileName.className = 'file-preview-name';
        fileName.textContent = file.name;
        filePreview.appendChild(fileName);
      }
      
      // Add remove button
      const removeButton = document.createElement('button');
      removeButton.className = 'file-preview-remove';
      removeButton.textContent = '√ó';
      removeButton.addEventListener('click', () => {
        // Remove from array
        attachedFiles = attachedFiles.filter(f => f !== file);
        
        // Remove from DOM
        filePreview.remove();
        
        // Hide container if no files left
        if (attachedFiles.length === 0) {
          attachedFilesContainer.style.display = 'none';
        }
      });
      filePreview.appendChild(removeButton);
      
      // Add the preview to the container
      attachedFilesContainer.appendChild(filePreview);
    }
    
    function getFileIcon(fileType) {
      if (fileType.startsWith('image/')) {
        return 'üñºÔ∏è';
      } else if (fileType.startsWith('text/')) {
        return 'üìÑ';
      } else if (fileType.includes('pdf')) {
        return 'üìë';
      } else if (fileType.includes('word') || fileType.includes('document')) {
        return 'üìù';
      } else if (fileType.includes('excel') || fileType.includes('spreadsheet')) {
        return 'üìä';
      } else if (fileType.includes('audio')) {
        return 'üéµ';
      } else if (fileType.includes('video')) {
        return 'üé¨';
      } else if (fileType.includes('zip') || fileType.includes('compressed')) {
        return 'üóúÔ∏è';
      } else if (fileType.includes('code') || fileType.includes('javascript') || fileType.includes('html') || fileType.includes('css')) {
        return 'üì±';
      } else {
        return 'üì¶';
      }
    }
    
    function addFilesToMessage(messageDiv, files) {
      if (!files || files.length === 0) return;
      
      files.forEach(file => {
        if (file.type.startsWith('image/')) {
          // Display images inline
          const reader = new FileReader();
          reader.onload = (e) => {
            const img = document.createElement('img');
            img.className = 'message-image';
            img.src = e.target.result;
            img.alt = file.name;
            
            // Add click event to open full size image
            img.addEventListener('click', () => {
              window.open(e.target.result, '_blank');
            });
            
            messageDiv.appendChild(img);
          };
          reader.readAsDataURL(file);
        } else {
          // For non-image files, display as attachment
          const attachment = document.createElement('div');
          attachment.className = 'message-file-attachment';
          
          const icon = document.createElement('div');
          icon.className = 'message-file-icon';
          icon.textContent = getFileIcon(file.type);
          attachment.appendChild(icon);
          
          const fileInfo = document.createElement('div');
          fileInfo.className = 'message-file-info';
          
          const fileName = document.createElement('div');
          fileName.className = 'message-file-name';
          fileName.textContent = file.name;
          fileInfo.appendChild(fileName);
          
          const fileSize = document.createElement('div');
          fileSize.className = 'message-file-size';
          fileSize.textContent = formatFileSize(file.size);
          fileInfo.appendChild(fileSize);
          
          attachment.appendChild(fileInfo);
          messageDiv.appendChild(attachment);
        }
      });
    }
    
    function formatFileSize(bytes) {
      if (bytes < 1024) return bytes + ' bytes';
      else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
      else return (bytes / 1048576).toFixed(1) + ' MB';
    }
  </script>
  <form hidden="" method="post" name="feedback">
    <input type="hidden" name="form-name" value="feedback">
    <input type="hidden" name="model">
    <input type="hidden" name="reasoning_method">
    <select name="feedback_type"></select>
    <input type="radio" name="rating" value="1">
    <input type="radio" name="rating" value="2">
    <input type="radio" name="rating" value="3">
    <input type="radio" name="rating" value="4">
    <input type="radio" name="rating" value="5">
    <textarea name="comments"></textarea>
  </form>

<script async="" id="netlify-rum-container" src="./LLM Playground (COT vs COD)_files/rum" data-netlify-rum-site-id="46b8ee21-754a-4a63-b741-fe88bac724f4" data-netlify-deploy-branch="main" data-netlify-deploy-context="production" data-netlify-cwv-token="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzaXRlX2lkIjoiNDZiOGVlMjEtNzU0YS00YTYzLWI3NDEtZmU4OGJhYzcyNGY0IiwiYWNjb3VudF9pZCI6IjY3YzU0MzUzYzc2MjdjOTUxZDZmNTU0MSIsImRlcGxveV9pZCI6IjY3Y2JjOGE0NzRlY2E1MDAwODQ5MWVhYiIsImlzc3VlciI6Im5mc2VydmVyIn0.eeKx8JPS1uEj-YKOwtWMAEBFgcCAjTWkB8RLzmCfMmI"></script>

</body></html>
